export const auxiliaryFunctions = {
  is_triangle: 'function is_triangle(a, b, c) {\n\treturn a + b > c && a + c > b && b + c > a\n}',
  distance:
    'function distance(a, b) {\n\tif (!a || !b) {\n\t\treturn 0\n\t}\n\t\n\treturn Math.round(Math.sqrt(Math.pow(a.position.x - b.position.x, 2) + Math.pow(a.position.y - b.position.y, 2)))\n}',
  count_blue_pieces:
    'function count_blue_pieces(board, boardKey) {\n  var count = 0\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.BLUE) {\n        count++\n      }\n    }\n  }\n  return count\n}',
  count_red_pieces:
    'function count_red_pieces(board, boardKey) {\n  var count = 0\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.RED) {\n        count++\n      }\n    }\n  }\n  return count\n}',
  count_empty_spaces:
    'function count_empty_spaces(board, boardKey) {\n  var count = 0\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.EMPTY) {\n        count++\n      }\n    }\n  }\n  return count\n}',
  find_first_red_piece:
  "function find_first_red_piece(board, boardKey) {\n\tfor (var i = 0; i < board.state[boardKey].length; i++) {\n\t\tfor (var j = 0; i < board.state[boardKey][i].length; j++) {\n\t\t\tif (\n\t\t\t\tboard.state[boardKey][i][j].color == Color.RED ||\n\t\t\t\t(board.state[boardKey][i][j].color == Color.STACK &&\n\t\t\t\t\tboard.state[boardKey][i][j].stack.red > 0)\n\t\t\t) {\n\t\t\t\treturn board.state[boardKey][i][j]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (\n\t\tboard.outOfBoundsState[boardKey].color == Color.RED ||\n\t\t(board.outOfBoundsState[boardKey].color == Color.STACK &&\n\t\t\tboard.outOfBoundsState[boardKey].stack.red > 0)\n\t) {\n\t\treturn board.outOfBoundsState[boardKey]\n\t}\n\n\treturn new Piece({ x: -2, y: -2 }, Color.EMPTY)\n}",
  find_first_blue_piece:
    "function find_first_blue_piece(board, boardKey) {\n\tfor (var i = 0; i < board.state[boardKey].length; i++) {\n\t\tfor (var j = 0; j < board.state[boardKey].length; j++) {\n\t\t\tif (\n\t\t\t\tboard.state[boardKey][i][j].color == Color.BLUE ||\n\t\t\t\t(board.state[boardKey][i][j].color == Color.STACK &&\n\t\t\t\t\tboard.state[boardKey][i][j].stack.blue > 0)\n\t\t\t) {\n\t\t\t\treturn board.state[boardKey][i][j]\n\t\t\t}\n\t\t}\n\t}\n\n\tif (\n\t\tboard.outOfBoundsState[boardKey].color == Color.BLUE || (\n\t\t\tboard.outOfBoundsState[boardKey].color == Color.STACK &&\n\t\t\tboard.outOfBoundsState[boardKey].stack.blue > 0\n\t\t)\n\t) {\n\t\treturn board.outOfBoundsState[boardKey]\n\t}\n\n\treturn new Piece({ x: -2, y: -2 }, Color.EMPTY)\n}",
  find_first_stack:
    'function find_first_stack(board, boardKey) {\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.STACK) {\n        return board.state[boardKey][i][j]\n      }\n    }\n  }\n\n  if (board.outOfBoundsState[boardKey].color == Color.STACK) {\n    return board.outOfBoundsState[boardKey]\n  }\n\n  return new Piece({ x: -2, y: -2 }, Color.EMPTY)\n}',
  find_blue_pieces:
    'function find_blue_pieces(board, boardKey) {\n  var vertices = []\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.BLUE) {\n        vertices.push(board.state[boardKey][i][j])\n      }\n    }\n  }\n\n  vertices.sort((a, b) => {\n    a.x - b.x == 0 ? a.y - b.y : a.x - b.x\n  })\n  return vertices\n}',
  find_red_pieces:
    'function find_red_pieces(board, boardKey) {\n  var vertices = []\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.RED) {\n        vertices.push(board.state[boardKey][i][j])\n      }\n    }\n  }\n  vertices.sort((a, b) => {\n    a.x - b.x == 0 ? a.y - b.y : a.x - b.x\n  })\n  return vertices\n}',
  find_stacks:
    'function find_stacks(board, boardKey) {\n  var vertices = []\n  for (var i = 0; i < board.state[boardKey].length; i++) {\n    for (var j = 0; j < board.state[boardKey].length; j++) {\n      if (board.state[boardKey][i][j].color == Color.STACK) {\n        vertices.push(board.state[boardKey][i][j])\n      }\n    }\n  }\n  vertices.sort((a, b) => {\n    a.x - b.x == 0 ? a.y - b.y : a.x - b.x\n  })\n  return vertices\n}',
  is_prime: "function is_prime(n) {\n\tfor(let i = 2, s = Math.sqrt(n); i <= s; i++) {\n\t\tif (n % i === 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn n > 1;\n}",
  triangle_perimeter: "function triangle_perimeter(board, boardKey) {\n\tvar vertices = this.find_blue_pieces(board, boardKey)\n\n\tif (vertices.length != 3) {\n\t\treturn 0\n\t}\n\n\tvar a = this.distance(vertices[0], vertices[1])\n\tvar b = this.distance(vertices[1], vertices[2])\n\tvar c = this.distance(vertices[2], vertices[0])\n\n\tif (!this.is_triangle(a, b, c)) {\n\t\treturn 0\n\t}\n\n\treturn Number.parseFloat(a + b + c).toFixed(2)\n}",
  is_pythagorean_triple: "function is_pythagorean_triple(board, boardKey) {\n\tvar vertices = this.find_blue_pieces(board, boardKey)\n\n\tvar a = this.distance(vertices[0], vertices[1])\n\tvar b = this.distance(vertices[1], vertices[2])\n\tvar c = this.distance(vertices[2], vertices[0])\n\n\treturn Math.pow(a, 2) + Math.pow(b, 2) == Math.pow(c, 2)\n}",
  has_adjacent_piece: "function has_adjacent_piece(board, boardKey, color) {\n\tvar vertices = this.find_blue_pieces(board, boardKey)\n\n\tvar directions = [\n\t\t{ x: 1, y: 1 },\n\t\t{ x: 1, y: -1 },\n\t\t{ x: -1, y: 1 },\n\t\t{ x: -1, y: -1 },\n\t\t{ x: 1, y: 0 },\n\t\t{ x: -1, y: 0 },\n\t\t{ x: 0, y: 1 },\n\t\t{ x: 0, y: -1 },\n\t]\n\n\tfor (var i = 0; i < vertices.length; i++) {\n\t\tfor (var j = 0; j < directions.length; j++) {\n\t\t\tvar x = parseFloat(vertices[i].position.x) + parseFloat(directions[j].x)\n\t\t\tvar y = parseFloat(vertices[i].position.y) + parseFloat(directions[j].y)\n\n\t\t\tif (x < 0 || x >= 8 || y < 0 || y >= 8) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tif (board.state[boardKey][x][y].color == color) {\n\t\t\t\treturn true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn false\n}",
  get_pieces: "function get_pieces(board, boardKey) {\n\tvar pieces = []\n\n\tfor (var i = 0; i < board.state[boardKey].length; i++) {\n\t\tfor (var j = 0; j < board.state[boardKey].length; j++) {\n\t\t\tif (board.state[boardKey][i][j].color != Color.EMPTY && board.state[boardKey][i][j].color != Color.STACK) {\n\t\t\t\tpieces.push(board.state[boardKey][i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pieces\n}",
  get_top_pieces: "function get_top_pieces(board, boardKey) {\n\tvar pieces = []\n\n\tfor (var i = 0; i < 4; i++) {\n\t\tfor (var j = 0; j < 8; j++) {\n\t\t\tif (board.state[boardKey][i][j].color != Color.EMPTY && board.state[boardKey][i][j].color != Color.STACK) {\n\t\t\t\tpieces.push(board.state[boardKey][i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pieces\n}",
  get_bottom_pieces: "function get_bottom_pieces(board, boardKey) {\n\tvar pieces = []\n\n\tfor (var i = 4; i < 8; i++) {\n\t\tfor (var j = 0; j < 8; j++) {\n\t\t\tif (board.state[boardKey][i][j].color != Color.EMPTY && board.state[boardKey][i][j].color != Color.STACK) {\n\t\t\t\tpieces.push(board.state[boardKey][i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pieces\n}"  ,
  get_left_pieces: "function get_left_pieces(board, boardKey) {\n\tvar pieces = []\n\n\tfor (var i = 0; i < 8; i++) {\n\t\tfor (var j = 0; j < 4; j++) {\n\t\t\tif (board.state[boardKey][i][j].color != Color.EMPTY && board.state[boardKey][i][j].color != Color.STACK) {\n\t\t\t\tpieces.push(board.state[boardKey][i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pieces\n}",
  get_right_pieces: "function get_right_pieces(board, boardKey) {\n\tvar pieces = []\n\n\tfor (var i = 0; i < 8; i++) {\n\t\tfor (var j = 4; j < 8; j++) {\n\t\t\tif (board.state[boardKey][i][j].color != Color.EMPTY && board.state[boardKey][i][j].color != Color.STACK) {\n\t\t\t\tpieces.push(board.state[boardKey][i][j])\n\t\t\t}\n\t\t}\n\t}\n\n\treturn pieces\n}"
}

export const auxiliaryFunctionsNames = Object.keys(auxiliaryFunctions)

