[
    {
        "id": 0,
        "name": "Challenge 1.1: Checking for Out of Bounds",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The condition guarding line 9 is made only using OR (||). What does that mean, logically?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x > 7"
            ]
        },
        "achievement": "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 10 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 10",
        "achievement_hint": "Consider that the numbers for the out of bounds spot start with 1 and are positive. Start with the lowest numbers!",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.2: Thorough Checking of Out of Bounds",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The condition is made only using OR (||)! You need to make sure that the condition yields both true and False.",
        "objective": "Decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "!(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement": "input.log[case_num][input.log[case_num].length - 1].destination.x == 10 && input.log[case_num][input.log[case_num].length - 1].destination.y == 20",
        "achievement_hint": "Consider, in one test case, that the row for the out of bounds spot starts with 1, and that the column starts with 2. Use the lowest POSITIVE numbers above 9!",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.3: Focus on the Destination",
        "test_cases_count": 5,
        "score": 500,
        "hint": "You only need 5 test cases to pass this challenge. Use the condition table, if needed.",
        "objective": "Modified condition/decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 4,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement": "input.log[case_num][input.log[case_num].length - 1].destination.x == 10",
        "achievement_hint": "Consider, in one test case, that the row (x) for the out of bounds spot starts with 1. Use the lowest POSITIVE numbers above 9!",
        "difficulty": "Hard",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.4: (Not) Moving Diagonally",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Think about what the condition in line 15 is testing. Knowing you can make all kinds of movements, can't you fulfill the condition?",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)"
            ]
        },
        "achievement": "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1 && Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y) == 4",
        "achievement_hint": "For challenge Y.X, consider moving Y rows, and X columns. Only the last movement made is considered!",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.5: Valid and Invalid Movement",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Considering the function is testing for valid moves in Checkers, you only need to make one valid and one invalid move... but validity is dictated by the condition in line 15!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y))"
            ]
        },
        "achievement": "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 5 && Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y) == 6",
        "achievement_hint": "For challenge X.Y, consider moving (Y * X) rows, and (X + Y) columns. Only the last movement made is considered!",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.6: A Valid Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You need to make a valid move, as defined by a certain condition evaluated to false. What condition is it?",
        "objective": "Statement coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "!(Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y))"
            ]
        },
        "achievement": "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 6 && Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y) == 6",
        "achievement_hint": "For challenge X.Y, move [(Y - 1) * 2 - 4] columns, and X*Y rows. Only the last movement made is considered!",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.7: A Normal Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a Checkers move, you always draw a square (as you follow one of its diagonals). Here, you're given the side of said square.",
        "objective": "Statement coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ]
        },
        "achievement": "(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y > 7) && ((input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 0 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 0) || (input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 7 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 7))",
        "achievement_hint": "Make a movement from outside of the board to one of the board's main diagonal corners.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.8: (Almost) A Capture Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a capture in Checkers, you always draw a square (as you follow one of its diagonals). If you have to go OVER a piece, what side does the square have?",
        "objective": "Statement coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ]
        },
        "achievement": "(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y > 7) && ((input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 0 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 0) || (input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 7 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 7))",
        "achievement_hint": "Make a movement from outside of the board to one of the board's main diagonal corners.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.9: All Possible Moves",
        "test_cases_count": 2,
        "score": 350,
        "hint": "If you're making a move in Checkers, you always draw a square (as you follow one of its diagonals). Each case corresponds to a difference side length of the square.",
        "objective": "Decision coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1)"
            ]
        },
        "achievement": "input.log[case_num][input.log[case_num].length - 1].destination.x + input.log[case_num][input.log[case_num].length - 1].destination.y == 9",
        "achievement_hint": "In one of test cases, consider the destination to be (row, column). Make sure row + column - 1 = 8.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.10: Moving to the Right Place",
        "test_cases_count": 1,
        "score": 175,
        "hint": "When you're making a normal movement (not a capture), you can only move to a spot that is one square away from your current position. What other condition must be true?",
        "objective": "Statement coverage of line 20.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1"
            ]
        },
        "achievement": "(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x == 0 && input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y == 0) || (input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x == 7 && input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y == 7) || (input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x == 0 && input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y == 7) || (input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x == 7 && input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y == 0)",
        "achievement_hint": "The board is a square. Make sure you start your move from a corner.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.11: Moving to a Wrong Place",
        "test_cases_count": 1,
        "score": 175,
        "hint": "Remember that you can do make things that aren't legal in Checkers! What condition must be false?",
        "objective": "Statement coverage of line 22.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": "this.find_stacks(input, input.currentKey).some((piece) => (piece.stack.red == 0 || piece.stack.blue == 0) && piece.color == 'stack')",
        "achievement_hint": "Make a stack by stacking pieces of the same color.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.12: Moving to Places",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Remember that you can do make things that aren't legal in Checkers! There are two clear cases to test, here.",
        "objective": "Decision coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)",
                "(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 0 ",
        "achievement_hint": "In one test case, the destination must only have X-colored pieces, if any. X = RGB(255, 0, 0).",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.13: Not Capturing a Piece, but Very Close",
        "test_cases_count": 1,
        "score": 175,
        "hint": "You don't have to have a piece in between your from and destination positions: notice the condition only cares about the destination!",
        "objective": "Statement coverage of line 26.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": "this.get_middle_piece(input, input.currentKey, input.log[input.currentKey][input.log[input.currentKey].length - 1].destination, input.log[input.currentKey][input.log[input.currentKey].length - 1].start).color == 'empty'",
        "achievement_hint": "The destination must pass the condition on line 25. Make sure the color of the middlePiece (line 26) is also empty.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.14: An Illegal Capture",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition true? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 28.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == this.get_middle_piece(input, input.currentKey, input.log[input.currentKey][input.log[input.currentKey].length - 1].destination, input.log[input.currentKey][input.log[input.currentKey].length - 1].start).color"
            ]
        },
        "achievement": "this.get_middle_piece(input, input.currentKey, input.log[input.currentKey][input.log[input.currentKey].length - 1].destination, input.log[input.currentKey][input.log[input.currentKey].length - 1].start).color == 'blue'",
        "achievement_hint": "The middlePiece (line 26) must be of Y color. Y = RGB(0, 0, 255).",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.15: Capture",
        "test_cases_count": 1,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 30.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color != this.get_middle_piece(input, input.currentKey, input.log[input.currentKey][input.log[input.currentKey].length - 1].destination, input.log[input.currentKey][input.log[input.currentKey].length - 1].start).color && this.get_middle_piece(input, input.currentKey, input.log[input.currentKey][input.log[input.currentKey].length - 1].destination, input.log[input.currentKey][input.log[input.currentKey].length - 1].start).color != 'empty'"
            ]
        },
        "achievement": "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == 'red'",
        "achievement_hint": "Move a red piece.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.16: Testing Captures",
        "test_cases_count": 2,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false and true, in different boards? Also, remember that only the last movement you made is considered.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color != this.get_middle_piece(input, case_num, input.log[case_num][input.log[case_num].length - 1].destination, input.log[case_num][input.log[case_num].length - 1].start).color",
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color == this.get_middle_piece(input, case_num, input.log[case_num][input.log[case_num].length - 1].destination, input.log[case_num][input.log[case_num].length - 1].start).color"
            ]
        },
        "achievement": "this.get_middle_piece(input, case_num, input.log[case_num][input.log[case_num].length - 1].destination, input.log[case_num][input.log[case_num].length - 1].start).color == 'red'",
        "achievement_hint": "Move a red piece in a test case!",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.17: Illegal Capture, Under a Condition",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination is true.",
        "objective": "Statement coverage of line 33.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue >= 2"
            ]
        },
        "achievement": "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == 'blue' || (input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == 'stack' && input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red == 0)",
        "achievement_hint": "Move a blue piece.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 1.18: Capturing Pieces, Under Conditions",
        "test_cases_count": 2,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination yields true and False in two different cases.",
        "objective": "Decision coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2",
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2)"
            ]
        },
        "achievement": "parseFloat(input.log[case_num][input.log[case_num].length - 1].destination.x) + parseFloat(input.log[case_num][input.log[case_num].length - 1].start.x) + parseFloat(input.log[case_num][input.log[case_num].length - 1].destination.y) + parseFloat(input.log[case_num][input.log[case_num].length - 1].start.y) == 18",
        "achievement_hint": "For challenge X.Y, make sure that start.x + start.y + destination.x + destination.y = Y.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.1: Counting Pieces",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12"
            ]
        },
        "achievement": "this.count_blue_pieces(input, input.currentKey) > 12 && this.count_red_pieces(input, input.currentKey) > 12",
        "achievement_hint": "For challenge X.Y. Make sure both colors have over (Y * 10 + X) pieces.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.2: No Pieces to Count",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0"
            ]
        },
        "achievement": "this.count_red_pieces(input, input.currentKey) == 0 && this.count_blue_pieces(input, input.currentKey) == 0",
        "achievement_hint": "Lighten the board by making it empty!",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.3: Counting Pieces, Not Counting Pieces",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 2 || Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 3",
        "achievement_hint": "For challenge X.Y, in one test case, make sure there is a difference of X or Y pieces between each set (red and blue).",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.4: Counting Pieces, Only When It Matters",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) <= 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) > 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) <= 12"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 8",
        "achievement_hint": "For challenge X.Y, in one test case, make sure the piece difference between the number of pieces of each set (red and blue) is Y * X.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.5: Win Conditions, Only When It Matters",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) != 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == 1 || this.count_red_pieces(input, case_num) == 1",
        "achievement_hint": "For challenge Y.X, make sure, in one test case, that one set of pieces (blue or red) only has (2*Y - X + 1) pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.6: Win Conditions, But Thoroughly",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) == 0",
                "!(this.count_blue_pieces(input, case_num) == 0) && !(this.count_red_pieces(input, case_num) == 0)"
            ]
        },
        "achievement": "(this.count_blue_pieces(input, case_num) == 6 && this.count_red_pieces(input, case_num) == 2) || (this.count_blue_pieces(input, case_num) == 2 && this.count_red_pieces(input, case_num) == 6)",
        "achievement_hint": "For challenge X.Y, make sure one test case has X pieces of one color and Y pieces of the other color.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.7: Counting Pieces, But Thoroughly",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12) && !(this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == 14 && this.count_red_pieces(input, case_num) == 14",
        "achievement_hint": "For challenge X.Y, make sure one test case has (X*Y) pieces of each color.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.8: Counting Pieces On Some Restrictions",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12",
                "this.count_red_pieces(input, case_num) > 12",
                "!(this.count_blue_pieces(input, case_num) > 12)",
                "!(this.count_red_pieces(input, case_num) > 12)"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 4",
        "achievement_hint": "For challenge Y.X, make one test case where there is a difference of X/Y between the number of pieces of each set (red and blue).",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.9: Winning Conditions On Some Restrictions",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 6.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0",
                "this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0",
                "this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement": "(this.count_blue_pieces(input, case_num) == 2 && this.count_red_pieces(input, case_num) == 7) || (this.count_blue_pieces(input, case_num) == 7 && this.count_red_pieces(input, case_num) == 2)",
        "achievement_hint": "For challenge X.Y, make sure one of the test cases has X pieces of one color and (Y - X) pieces of the other color.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.10: Valid Positions for Odd Rows",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "!(this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12)",
                "!(this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0)"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![1, 3, 5, 7].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": "(parseFloat(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x) + parseFloat(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y)) * 2 == 10",
        "achievement_hint": "For challenge X.Y, make one test case where the last interaction makes the following true: [(start.x + start.y) * 2 = 10].",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.11: Valid Positions for Even Rows",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 21.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "!(this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12)",
                "!(this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0)"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![0, 2, 4, 6].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement": "(parseFloat(input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) + parseFloat(input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)) + 2 == 11",
        "achievement_hint": "For challenge Y.X, make sure the last interaction makes this expression true: [destination.x + destination.y + 2 = 11].",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.12: Just Odd Rows",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Not all is what it seems. Pay attention to the code.",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "!(this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12)",
                "!(this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0)"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": "this.count_blue_pieces(input, input.currentKey) + this.count_red_pieces(input, input.currentKey) <= 22",
        "achievement_hint": "For challenge Y.X, make sure there are at most (X * Y - Y) pieces in the board.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.13: Just Even Rows",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Pay attention to the code. You MUST use the Add button.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "!(this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12)",
                "!(this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0)"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": "this.count_blue_pieces(input, input.currentKey) + this.count_red_pieces(input, input.currentKey) <= 15",
        "achievement_hint": "For challenge Y.X, make sure you have at most (X + Y) pieces in the board.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.14: All Rows",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Pay attention to the code condition! You don't need to care what's inside the branches of the If, only that execution gets there!",
        "objective": "Decision coverage of line 15. Note that only one test case is necessary, because of the for loop!",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "!(this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12)",
                "!(this.count_blue_pieces(input, case_num) == 0 || this.count_red_pieces(input, case_num) == 0)"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => Number(piece.position.x) % 2 != 0)",
                "this.get_pieces(input, case_num).some((piece) => Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == 7 && this.count_red_pieces(input, case_num) == 7",
        "achievement_hint": "For challenge X.Y, make a test case where you have (Y / X) pieces of each color.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 2.15: A Valid Board",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You have a lot of hurdles to get through, and the Add button is your friend - it adds AND removes pieces (check Guide, if needed).",
        "objective": "Statement coverage of line 26.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) <= 12 && this.count_red_pieces(input, input.currentKey) <= 12",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => (Number(piece.position.x) % 2 != 0 && [1, 3, 5, 7].includes(Number(piece.position.y))) || (Number(piece.position.x) % 2 == 0 && [0, 2, 4, 6].includes(Number(piece.position.y))))"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey).slice(0, 12).every((piece) => piece.color == 'blue') && this.get_pieces(input, input.currentKey).slice(12, 25).every((piece) => piece.color == 'red')",
        "achievement_hint": "Blue pieces should be placed above red pieces, i.e., in rows with lower numbers",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.1: A King Piece",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check the How to Play page to know how one makes a King. Only one King piece is needed!",
        "objective": "Statement coverage of line 13.\nNOTE: Use boards with only one King piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement": "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x) == 7",
        "achievement_hint": "For challenge X.Y, make a final interaction that makes this expression true: [|destination.x - start.x| = 2*X + Y].",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.2: A King Can Go Anywhere",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check the How to Play page to know how one makes a King. Only one King piece is needed - if you put more than one, only the first is considered.",
        "objective": "Statement coverage of line 20.\nNOTE: Use boards with only one King piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": "var s = 0; this.get_pieces(input, input.currentKey).filter(piece => piece.king).forEach(piece => [{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].forEach(position => (input.state[input.currentKey][(parseFloat(piece.position.x) + parseFloat(position.x) > 7) ? 7 : (parseFloat(piece.position.x) + parseFloat(position.x) < 0) ? 0 : parseFloat(piece.position.x) + parseFloat(position.x)][(parseFloat(piece.position.y) + parseFloat(position.y) > 7) ? 7 : (parseFloat(piece.position.y) + parseFloat(position.y) < 0) ? 0 : parseFloat(piece.position.y) + parseFloat(position.y)].color != 'empty') ? s++ : 'nothing' )); s == 2",
        "achievement_hint": "For challenge X.Y, block Y diagonally adjacent positions of a King. Use the directions defined on the code.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.3: Testing Kings",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check the How to Play page to know how one makes a King. Only one King piece is needed!",
        "objective": "Decision coverage of lines 17-19.\nNOTE: These lines are within a for-loop, so only 1 test case is enough. Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63",
                "this.get_pieces(input, case_num).length != 1 && this.get_pieces(input, case_num)[0].king"
            ],
            "tests": [
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].every(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": "this.get_pieces(input, case_num).length == 6",
        "achievement_hint": "For challenge X.Y, make sure you have exactly X + Y pieces in a test case.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.4: A King and a Peasant",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check the How to Play page to know how one makes a King. You cannot use more than one King piece!",
        "objective": "Decision coverage of line 12.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement": "this.get_pieces(input, case_num).filter((piece) => piece.king == true)[0].color == Color.BLUE",
        "achievement_hint": "Use a blue king.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.5: A Red Piece",
        "test_cases_count": 1,
        "score": 300,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 28.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey)[0].position.x == 3 && this.get_pieces(input, input.currentKey)[0].position.y == 5",
        "achievement_hint": "For challenge X.Y, place the piece on row X and column Y.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.6: (NOT) A Red Piece",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 43.\n\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color != Color.RED)"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey)[0].position.x == 6 && this.get_pieces(input, input.currentKey)[0].position.y == 3",
        "achievement_hint": "For challenge X.Y, place the piece on column X and row Y.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.7: Double The Colors!",
        "test_cases_count": 1,
        "score": 350,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Decision coverage of line 27.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color != Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey)[0].position.x == 4 && this.get_pieces(input, input.currentKey)[0].position.y == 3",
        "achievement_hint": "For challenge X.Y, have a test case with a piece placed on row (Y - X) and column X.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.8: Under The Condition of Being King",
        "test_cases_count": 2,
        "score": 225,
        "hint": "You can check the How to Play page to know how one makes a King. Only one King piece is allowed.",
        "objective": "Condition coverage of line 12.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey)[0].position.x == 3 && this.get_pieces(input, input.currentKey)[0].position.y == 5",
        "achievement_hint": "For challenge X.Y, make sure one of the test cases has a piece placed on row X and column (Y - X).",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.9: A Valid Position for a Red Piece",
        "test_cases_count": 1,
        "score": 250,
        "hint": "Only one piece needs to pass the test in each test case! You can check the How to Play page to know how movement works.",
        "objective": "Statement coverage of line 36.\nNOTE: Use boards with only one red piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_empty_spaces(input, input.currentKey) == 63",
                "this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].every(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && piece.color == 'red' && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey).filter((piece) => piece.color == 'blue').length == 3 && this.get_pieces(input, input.currentKey).filter((piece) => piece.color == 'red').length == 1",
        "achievement_hint": "For challenge X.Y, use a board with one red piece and (Y / X - 1) blue pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.10: Can A Red Piece Move?",
        "test_cases_count": 2,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check the How to Play page to know how movement works.",
        "objective": "Decision coverage of lines 33-35.\nNOTE: These lines are within a for-loop, so only 1 test case is enough.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).filter((piece) => piece.color == 'red').some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "![{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).filter((piece) => piece.color == 'red').some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) ==  4",
        "achievement_hint": "For challenge X.Y, make sure one test case has [Y - X*X + X] blue pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.11: Both Colors Move",
        "test_cases_count": 2,
        "score": 300,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check the How to Play page to know how movement works.",
        "objective": "Decision coverage of line 27.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": "this.get_pieces(input, input.currentKey)[0].position.x == 3 && this.get_pieces(input, input.currentKey)[0].position.y == 4",
        "achievement_hint": "For challenge X.Y, make one test case have a piece placed on row X and column ((Y - X)/2).",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.12: Move When Red, Move When Blue",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check the How to Play page to know how movement works.",
        "objective": "Condition/decision coverage of line 27.\nNOTE: Use boards with only one piece.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.count_empty_spaces(input, case_num) == 63",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == 5 && this.count_red_pieces(input, case_num) == 5",
        "achievement_hint": "For challenge X.Y, make sure a test case has (Y - X)/2 pieces of each color.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.13: Testing King Movement Semi-Thoroughly",
        "test_cases_count": 1,
        "score": 325,
        "hint": "You can check the How to Play page to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of lines 17-19.\nNOTE: These lines are within a for-loop, so only 1 test case is enough. Use boards with only one King.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && !(input.state[case_num][newX][newY].color == Color.EMPTY); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && !(input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY); }))"
            ]
        },
        "achievement": "this.count_red_pieces(input, case_num) == this.get_pieces(input, case_num).length || this.count_blue_pieces(input, case_num) == this.get_pieces(input, case_num).length",
        "achievement_hint": "Use pieces of one color only!",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 3.14: Can A Blue Piece Move?",
        "test_cases_count": 1,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check the How to Play page to know how movement works.",
        "objective": "Decision coverage of line 47-49.\nNOTE: These lines are within a for-loop, so only 1 test case is enough.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"

            ],
            "tests": [
                "[{ x: -1, y: 1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "![{ x: -1, y: 1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && newX + direction.x >= 0 && newY + direction.y >= 0 && newX + direction.x <= 7 && newY + direction.y <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)",
        "achievement_hint": "In one test case, make sure that both colors get an equal number of pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.1: Only One Piece",
        "test_cases_count": 1,
        "score": 125,
        "hint": "You can choose the piece's color. But you must only put one piece!",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).length == 1"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).color == 'stack'",
        "achievement_hint": "Beyond a singular piece, have a stack on the board.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.2: One Piece... or More",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.red == 0 && this.find_first_stack(input, case_num).color == 'stack'",
        "achievement_hint": "In one test case, have just ONE stack of only blue pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.3: A Piece... Under a Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.blue == 0 && this.find_first_stack(input, case_num).color == 'stack'",
        "achievement_hint": "In one test case, have a stack of only red pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.4: Decide A Piece... Under a Condition!",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.red == this.find_first_stack(input, case_num).stack.blue && this.find_first_stack(input, case_num).color == 'stack'",
        "achievement_hint": "In one test case, have a stack of an equal number of red and blue pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.5: Only One Color!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "An empty board won't work for either test case. Choose a color, but beware of the first If!",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": "this.find_first_single_piece(input, input.currentKey).color != (this.find_first_stack(input, input.currentKey).stack.red > 0 ? 'red' : (this.find_first_stack(input, input.currentKey).stack.blue > 0 ? 'blue' : 'stack'))",
        "achievement_hint": "Add one stack of pieces of a color different from the one you choose to pass the challenge.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.6: Only One Color... Or Not!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. For the other, pick a color! Beware of the first If.",
        "objective": "Decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!(this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE))"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).color != 'empty'",
        "achievement_hint": "Submit a stack in one test case.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.7: Another Colorful Condition",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board CAN work for one of the needed test cases. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": "this.is_prime(this.get_pieces(input, case_num).length)",
        "achievement_hint": "In one test case, have a prime number of total pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.8: Another Colorful Condition",
        "test_cases_count": 1,
        "score": 250,
        "hint": "Could an empty board work? You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Statement coverage of line 10.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.get_pieces(input, input.currentKey).length != 1"
            ],
            "tests": [
                "!(this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE))"
            ]
        },
        "achievement": "!this.is_prime(this.get_pieces(input, input.currentKey).length)",
        "achievement_hint": "Add a non-prime number of total pieces to the board.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 4.9: Thoroughly Testing the Colorful Condition",
        "test_cases_count": 3,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every(piece => piece.color == Color.RED) && !this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every(piece => piece.color == Color.RED) && this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)",
                "this.get_pieces(input, case_num).length == 0 || (!(this.get_pieces(input, case_num).every(piece => piece.color == Color.RED)) && !(this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)))"
            ]
        },
        "achievement": "this.is_prime(this.find_first_stack(input, case_num).stack.red + this.find_first_stack(input, case_num).stack.blue)",
        "achievement_hint": "In one test case, add a stack with a prime number of pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.1: Equal Footing",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Zero is a number, just saying.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement": "(this.find_first_stack(input, input.currentKey).stack.red + this.find_first_stack(input, input.currentKey).stack.blue == 5) && this.find_stacks(input, input.currentKey).length == 1",
        "achievement_hint": "For challenge X.Y, make Y stack(s) with X total pieces.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.2: Evenly Matched... or Not!",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number, by the way. But you can't use it for both test cases!",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": "this.count_red_pieces(input, case_num) == 5 && this.count_blue_pieces(input, case_num) == 2",
        "achievement_hint": "For challenge X.Y, in one test case, use X red pieces and Y blue pieces.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.3: Equally Conditioned",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number! But it's not useful for both test cases.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": "this.count_red_pieces(input, case_num) == 3 && this.count_blue_pieces(input, case_num) == 5",
        "achievement_hint": "For challenge Y.X, in one test case, use X red pieces and Y blue pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.4: Equally Conditioned Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number! But it's not useful for both test cases.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.red == 4 && this.find_first_stack(input, case_num).stack.blue == 1",
        "achievement_hint": "For challenge Y.X, in one test case, make a stack with X red pieces and (Y - X) blue pieces.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.5: Everyone Wins!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Using an empty board here is not possible. In the most basic terms (number of pieces per player), what is a tie?",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).color != 'empty'",
        "achievement_hint": "Pass the challenge with a stack.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.6: No One Wins?",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Only one number of pieces per player will work here. Remember: the board is an 8 by 8 grid!",
        "objective": "Statement coverage of line 11.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).color != 'empty'",
        "achievement_hint": "Pass the challenge with a stack... but you can't put it on the board, can you?",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.7: A Tie... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": "this.get_pieces(input, case_num).length <= 2",
        "achievement_hint": "For challenge Y.X, make one test case with, at most, (X - Y) occupied spots.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.8: Conditioned Tie",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Condition coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": "Math.abs(this.find_first_stack(input, case_num).stack.red - this.find_first_stack(input, case_num).stack.blue) == 3",
        "achievement_hint": "For challenge X.Y, make sure a test case has a stack with a difference of (Y - X) pieces between colors.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.9: Conditioning and Deciding A Tie",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Condition/decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) == 5 || this.count_red_pieces(input, case_num) == 5",
        "achievement_hint": "For challenge X.Y, make sure one test case has X pieces of the same color.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.10: Not A Tie",
        "test_cases_count": 1,
        "score": 100,
        "hint": "You can't use an empty board, here... That would lead to an early return!",
        "objective": "Statement coverage of line 14.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, input.currentKey) - this.count_red_pieces(input, input.currentKey)) == 2",
        "achievement_hint": "For challenge X.Y, make sure there is a difference of (Y/X) pieces between colors.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.11: A Blue (But Not Sad) Victory!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 15.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": "Math.abs(this.count_red_pieces(input, input.currentKey) - this.count_blue_pieces(input, input.currentKey)) == 6",
        "achievement_hint": "For challenge Y.X, make sure there is a difference of |(Y - X)| pieces between colors.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.12: A Red (But Not Angry) Victory!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement": "Math.abs(this.count_red_pieces(input, input.currentKey) - this.count_blue_pieces(input, input.currentKey)) == 2",
        "achievement_hint": "For challenge X.Y, make sure there is a difference of |2*X - Y| pieces between colors.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.13: Colorful Victories",
        "test_cases_count": 2,
        "score": 225,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.red != 0 && this.find_first_stack(input, case_num).stack.red == this.find_first_stack(input, case_num).stack.blue",
        "achievement_hint": "In one test case, make a stack where both colors have the same number of pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.14: Colorful Conditioned Victories",
        "test_cases_count": 2,
        "score": 250,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Condition coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 3",
        "achievement_hint": "For challenge X.Y, make sure there is a difference of [|(2*X - Y)| - 1] pieces between colors.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 5.15: Colorful Conditioned Decisions",
        "test_cases_count": 2,
        "score": 275,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Condition/decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, case_num) - this.count_red_pieces(input, case_num)) == 6",
        "achievement_hint": "For challenge Y.X, make sure there is a difference of 2*(Y/X) pieces between colors.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.1: Build-a-Triangle",
        "test_cases_count": 1,
        "score": 175,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 7.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.is_triangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement": "this.is_prime(this.count_red_pieces(input, input.currentKey)) || this.is_prime(this.count_blue_pieces(input, input.currentKey)) || this.is_prime(this.count_empty_spaces(input, input.currentKey))",
        "achievement_hint": "Make sure one of the triangle's sides is a prime number.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.2: Don't-Build-a-Triangle",
        "test_cases_count": 1,
        "score": 100,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.is_triangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement": "(this.count_red_pieces(input, input.currentKey) + this.count_blue_pieces(input, input.currentKey)) % 2 == 0",
        "achievement_hint": "Make sure the sum of red and blue pieces is an even number.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.3: Triangular Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Decision coverage of line 7.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": "(this.count_red_pieces(input, case_num) % 2 == 0 && this.count_blue_pieces(input, case_num) % 2 != 0) || (this.count_blue_pieces(input, case_num) % 2 == 0 && this.count_red_pieces(input, case_num) % 2 != 0)",
        "achievement_hint": "In one test case, make sure one color has an even number of pieces, and the other has an odd number of pieces.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.4: Triangular Condition",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Condition coverage of line 7.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": "Math.pow(Math.sqrt(this.count_red_pieces(input, case_num)), 2) == this.count_red_pieces(input, case_num)",
        "achievement_hint": "In one test case, make sure that the number of red pieces is a perfect square.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.5: Triangular Conditional Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Condition/decision coverage of line 7.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": "(this.count_red_pieces(input, case_num) + this.count_blue_pieces(input, case_num)) % 2 != 0",
        "achievement_hint": "In one test case, make sure that the sum of red and blue pieces is an odd number.",
        "difficulty": "Very Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.6: Don't-Build-Or-Build-a-Triangle",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Decision coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ]
        },
        "achievement": "this.count_empty_spaces(input, case_num) >= this.count_red_pieces(input, case_num) + this.count_blue_pieces(input, case_num)",
        "achievement_hint": "In one test case, make the number of empty spaces be bigger or equal to all pieces combined.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.7: Triangulating Condition",
        "test_cases_count": 2,
        "score": 450,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Condition coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ]
        },
        "achievement": "this.count_red_pieces(input, case_num) > this.count_empty_spaces(input, case_num)",
        "achievement_hint": "In one test case, make the number of red pieces equal to or bigger than the sum of empty spaces and blue pieces combined.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.8: Never A Scalene Triangle",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You cannot make a triangle, nor can the condition on line 9 be hit!",
        "objective": "Statement coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey) && this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).stack.red == 0 && this.find_first_stack(input, input.currentKey).color != 'empty'",
        "achievement_hint": "Add a stack of blue pieces on the out of bounds spot.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.9: Conditioning An Isosceles Triangle",
        "test_cases_count": 2,
        "score": 450,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. You're dealing with two separate conditions, so cover true-False state for each, across two test cases! Also, notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Condition coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey) && this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
        "achievement_hint": "In one test case, make sure that the number of blue pieces is smaller than the number of empty spaces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.10: Deciding If It's An Isosceles Triangle",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || (this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)))",
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).stack.red == this.find_first_stack(input, case_num).stack.blue",
        "achievement_hint": "Make sure, in one test case, there is a stack with an equal number of red and blue pieces.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.11: In Theory, An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Statement coverage of line 13",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).color != 'empty' && this.find_first_stack(input, input.currentKey).stack.red != 0 && this.find_first_stack(input, input.currentKey).stack.blue != 0",
        "achievement_hint": "Make sure there is at least one stack with both red and blue pieces on the board.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.12: Thoroughly Testing A Theoretical Isosceles Triangle",
        "test_cases_count": 3,
        "score": 350,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Modified condition/decision coverage of line 11",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)"
            ]
        },
        "achievement": "this.count_red_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
        "achievement_hint": "In one test case, make sure the number of red pieces and empty spaces is different.",
        "difficulty": "Hard",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.13: Thoroughly Testing A Theoretical Scalene Triangle",
        "test_cases_count": 3,
        "score": 350,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Modified condition/decision coverage of line 10",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) >= this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) <= this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)"
            ]
        },
        "achievement": "this.find_first_stack(input, case_num).color != 'empty' && this.find_first_stack(input, case_num).stack.blue == 0",
        "achievement_hint": "In one test case, add a stack of only red pieces on the out of bounds spot.",
        "difficulty": "Hard",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 6.14: If This Was A Triangle, We'd Be Concerned",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Treat the first three If conditions as landmines - you can't cover them!",
        "objective": "Statement coverage of line 15.",
        "initial_board": 1,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.is_triangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)) || !(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement": "this.find_first_stack(input, input.currentKey).color != 'empty' && this.find_first_stack(input, input.currentKey).stack.red == 0",
        "achievement_hint": "Add a stack of only blue pieces on the out of bounds spot.",
        "difficulty": "Hard",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.1: Draw A Right Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 31.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ]
        },
        "achievement": "this.triangle_perimeter(input, input.currentKey) >= 12",
        "achievement_hint": "Make sure the triangle's perimeter is above or equal to 12.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.2: Don't Draw A Right Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ]
        },
        "achievement": "this.count_red_pieces(input, input.currentKey) == 5",
        "achievement_hint": "For challenge X.Y, make sure there are 5 red pieces on the board.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.3: Drawing A Right Triangle... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Decision coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": "this.is_pythagorean_triple(input, case_num)",
        "achievement_hint": "Make sure the right triangle in test true-branch test case has a trio of Pythagorean triples as its sides.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.4: Drawing A Right Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Condition coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": "[{x: 0, y: 0}, {x: 0, y: 7}, {x: 7, y: 0}, {x: 7, y: 7}].filter((point) => input.state[case_num][point.x][point.y].color == 'red').length == 3",
        "achievement_hint": "For challenge Y.X, in one test case, make sure (Y - X) corners of the board are occupied by a red piece.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.5: Drawing A Right Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Condition/decision coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": "this.has_adjacent_piece(input, case_num, 'red')",
        "achievement_hint": "In one test case, place a red piece adjacent to a triangle vertex.",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.6: Draw A Scalene Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 33.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3"
            ]
        },
        "achievement": "this.has_adjacent_piece(input, input.currentKey, 'stack') && this.find_first_stack(input, input.currentKey).stack.blue == 0",
        "achievement_hint": "Place a stack of red pieces adjacent to a triangle vertex.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.7: Don't Draw A Scalene Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 34.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ]
        },
        "achievement": "input.state[input.currentKey][7][7].color == 'red'",
        "achievement_hint": "For challenge Y.X, place a red piece on position (X, Y).",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.8: Draw A Scalene Triangle... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": "input.outOfBoundsState[case_num].position.x == 7 && input.outOfBoundsState[case_num].position.y == 8 && input.outOfBoundsState[case_num].color == 'red'",
        "achievement_hint": "For challenge X.Y, place a red piece on position (X, Y).",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.9: Draw A Scalene Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Condition coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": "input.outOfBoundsState[case_num].position.x == 63 && input.outOfBoundsState[case_num].position.y == 63 && input.outOfBoundsState[case_num].color == 'red'",
        "achievement_hint": "For challenge X.Y, in one test case, place a red piece on position (X*Y, Y*X).",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.10: Draw A Scalene Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Condition/decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": "input.state[case_num][7][3].color == 'stack' && input.state[case_num][7][3].stack.red == 3",
        "achievement_hint": "For challenge X.Y, in one test case, place (Y - X) red pieces on position (X, Y - X)",
        "difficulty": "Normal",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.11: Draw An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 35.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2"
            ]
        },
        "achievement": "input.outOfBoundsState[input.currentKey].position.x == -4 && input.outOfBoundsState[input.currentKey].position.y == 18 && input.outOfBoundsState[input.currentKey].color == 'red'",
        "achievement_hint": "For challenge Y.X, place a red piece on position (Y - X, Y + X).",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.12: Don't Draw An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ]
        },
        "achievement": "Math.abs(this.count_blue_pieces(input, input.currentKey) - this.count_red_pieces(input, input.currentKey)) == 5",
        "achievement_hint": "For challenge X.Y, make sure there is a difference of |(X - Y)| pieces between colors.",
        "difficulty": "Easy",
        "owner_id": 1,
        "visible": true
    },
    {
        "id": 0,
        "name": "Challenge 7.13: Theoretically, It's An Equilateral Triangle",
        "test_cases_count": 1,
        "score": 200,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Statement coverage of line 37.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && [...(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]))] == 0"
            ]
        },
        "achievement": "input.outOfBoundsState[input.currentKey].position.x == 13 && input.outOfBoundsState[input.currentKey].position.y == 7 && input.outOfBoundsState[input.currentKey].stack.red == input.outOfBoundsState[input.currentKey].stack.blue && input.outOfBoundsState[input.currentKey].stack.red + input.outOfBoundsState[input.currentKey].stack.blue == 6",
        "achievement_hint": "For challenge Y.X, make a stack of |(X - Y)| pieces in position (X, Y), with the same number of red and blue pieces.",
        "difficulty": "Hard",
        "owner_id": 1,
        "visible": true
    }
]