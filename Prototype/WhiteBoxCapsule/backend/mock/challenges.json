[
    {
        "id": 0,
        "name": "Challenge 1.1: Checking for Out of Bounds",
        "description": "Pieces can never leave the board.",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The condition guarding line 9 is made only using OR (||). What does that mean, logically?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x > 7"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.2: Thorough Checking of Out of Bounds",
        "description": "What if pieces could go out of bounds?",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The condition is made only using OR (||)! You need to make sure that the condition yields both True and False.",
        "objective": "Decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "!(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.3: Focus on the Destination",
        "description": "In this challenge, only the destination is tested, as thoroughly as possible.",
        "test_cases_count": 5,
        "score": 500,
        "hint": "You only need 5 test cases to pass this challenge. Use the condition table, if needed.",
        "objective": "Modified condition/decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "condition_count": 4,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.4: (Not) Moving Diagonally",
        "description": "Checkers only allows for diagonal movement. You need to avoid that, in this challenge.",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Think about what the condition in line 15 is testing. Knowing you can make all kinds of movements, can't you fulfill the condition?",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.5: Valid and Invalid Movement",
        "description": "In this challenge, you need to test both valid and invalid movement.",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Considering the function is testing for valid moves in Checkers, you only need to make one valid and one invalid move... but validity is dictated by the condition in line 15!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.6: A Valid Move",
        "description": "In this challenge, you need to make a valid move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You need to make a valid move, as defined by a certain condition evaluated to false. What condition is it?",
        "objective": "Statement coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "!(Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.7: A Normal Move",
        "description": "In this challenge, you need to make a normal Checkers move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a Checkers move, you always draw a square (as you follow one of its diagonals). Here, you're given the side of said square.",
        "objective": "Statement coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.8: (Almost) A Capture Move",
        "description": "In this challenge, you need to make a capture move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a capture in Checkers, you always draw a square (as you follow one of its diagonals). If you have to go OVER a piece, what side does the square have?",
        "objective": "Statement coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.9: All Possible Moves",
        "description": "In this challenge, you need to test all possible moves!",
        "test_cases_count": 2,
        "score": 350,
        "hint": "If you're making a move in Checkers, you always draw a square (as you follow one of its diagonals). Each case corresponds to a difference side length of the square.",
        "objective": "Decision coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.10: Moving to the Right Place",
        "description": "In this challenge, you need to make an actual Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "When you're making a normal movement (not a capture), you can only move to a spot that is one square away from your current position. What other condition must be true?",
        "objective": "Statement coverage of line 20.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.11: Moving to a Wrong Place",
        "description": "In this challenge, you need to make an illegal Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "Remember that you can do make things that aren't legal in Checkers! What condition must be false?",
        "objective": "Statement coverage of line 22.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.12: Moving to Places",
        "description": "In this challenge, you need to make an illegal and a totally valid Checkers move!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Remember that you can do make things that aren't legal in Checkers! There are two clear cases to test, here.",
        "objective": "Decision coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)",
                "(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.13: Not Capturing a Piece, but Very Close",
        "description": "In this challenge, you need to make a potentially valid Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "You don't have to have a piece in between your from and destination positions: notice the condition only cares about the destination!",
        "objective": "Statement coverage of line 26.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.14: An Illegal Capture",
        "description": "To make sure captures work correctly.",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition true? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 28.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.15: Capture",
        "description": "Testing a real capture move.",
        "test_cases_count": 1,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 30.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color != input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color && input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color != 'empty'"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.16: Testing Captures",
        "description": "Testing a real and an illegal capture move.",
        "test_cases_count": 2,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false and true, in different boards? Also, remember that only the last movement you made is considered.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color != input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color",
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color == input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.17: Illegal Capture, Under a Condition",
        "description": "Testing an illegal capture move.",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination is True.",
        "objective": "Statement coverage of line 33.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue >= 2"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.18: Capturing Pieces, Under Conditions",
        "description": "Testing an illegal capture and a valid capture move.",
        "test_cases_count": 2,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination yields True and False in two different cases.",
        "objective": "Decision coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2",
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.1: Counting Pieces",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.2: No Pieces to Count",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.3: Counting Pieces, Not Counting Pieces",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.4: Counting Pieces, Only When It Matters",
        "description": "Not all test cases are equal in this challenge.",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) <= 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) > 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) <= 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.5: Win Conditions, Only When It Matters",
        "description": "Only some test cases are relevant in this challenge.",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) != 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.6: Win Conditions, But Thoroughly",
        "description": "All test cases are relevant in this challenge.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) == 0",
                "!(this.count_blue_pieces(input, case_num) == 0) && !(this.count_red_pieces(input, case_num) == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.7: Counting Pieces, But Thoroughly",
        "description": "You need to submit all possible test cases in this challenge.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12) && !(this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.8: Counting Pieces On Some Restrictions",
        "description": "You need to cover all values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) <= 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.9: Winning Conditions On Some Restrictions",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.10: Valid Positions for Odd Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![1, 3, 5, 7].includes(piece.position.y) && piece.position.x % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.11: Valid Positions for Even Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 21.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![0, 2, 4, 6].includes(piece.position.y) && piece.position.x % 2 == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.12: Just Odd Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Not all is what it seems. Pay attention to the code.",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.position.x % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.13: Just Even Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Pay attention to the code. You MUST use the Add button.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.position.x % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.14: All Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Pay attention to the code condition! You don't need to care what's inside the branches of the If, only that execution gets there!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 0,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.position.x % 2 != 0)",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.position.x % 2 == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.15: A Valid Board",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You have a lot of hurdles to get through, and the Add button is your friend - it adds AND removes pieces (check Guide, if needed).",
        "objective": "Statement coverage of line 26.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": 2,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) <= 12 && this.count_red_pieces(input, input.currentKey) <= 12",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => (piece.position.x % 2 != 0 && [1, 3, 5, 7].includes(piece.position.y)) || (piece.position.x % 2 == 0 && [0, 2, 4, 6].includes(piece.position.y)))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.1: A King Piece",
        "description": "You're going to meet royalty!",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Statement coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.2: A King Can Go Anywhere",
        "description": "Royals have no restrictions!",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first is considered.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.3: Testing Kings",
        "description": "Not all royalty can move freely.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))",
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.4: A King and a Peasant",
        "description": "Some pieces aren't born into royalty.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.5: A Red Piece",
        "description": "Some peasants are red.",
        "test_cases_count": 1,
        "score": 300,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 28.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.6: (NOT) A Red Piece",
        "description": "Some peasants aren't red.",
        "test_cases_count": 1,
        "score": 300,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 43.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color != Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.7: Double The Colors!",
        "description": "Some peasants are red, others are not.",
        "test_cases_count": 1,
        "score": 400,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 43.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color != Color.RED)",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.8: Under The Condition of Being King",
        "description": "Some pieces aren't born into royalty.",
        "test_cases_count": 2,
        "score": 400,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.9: A Valid Position for a Red Piece",
        "description": "They can only go 'down'!",
        "test_cases_count": 2,
        "score": 400,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king) || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.10: Can A Red Piece Move?",
        "description": "They can only go 'down'!",
        "test_cases_count": 2,
        "score": 400,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 33.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king) || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))",
                "![{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.11: Both Colors Move",
        "description": "They go in opposite directions!",
        "test_cases_count": 2,
        "score": 400,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.12: Thoroughly Testing Red Piece Movement",
        "description": "They can only go 'down'!",
        "test_cases_count": 4,
        "score": 700,
        "hint": "Only one red piece in your submissions needs to pass the tests. You can check Checkers' rules to know how movement works.",
        "objective": "Modified condition/decision coverage of line 33.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY)",
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.13: Thoroughly Testing Blue Piece Movement",
        "description": "They can only go 'up'!",
        "test_cases_count": 4,
        "score": 700,
        "hint": "Only one blue piece in your submissions needs to pass the tests. You can check Checkers' rules to know how movement works.",
        "objective": "Modified condition/decision coverage of line 47.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY)",
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.14: Movement Under a Colorful Condition",
        "description": "They go in opposite directions!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Condition coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "condition_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "!this.get_pieces(input, input.currentKey)[0].some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.15: Move When Red, Move When Blue",
        "description": "Making decisions according to conditions!",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Condition coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "condition_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.16: Testing King Movement Semi-Thoroughly",
        "description": "Not all royalty can move freely!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "condition_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))",
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.17: Thoroughly Testing King Movement",
        "description": "They can go in all directions!",
        "test_cases_count": 4,
        "score": 700,
        "hint": "Only one blue piece in your submissions needs to pass the tests. You can check Checkers' rules to know how movement works.",
        "objective": "Modified condition/decision coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "condition_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)",
                "!this.get_pieces(input, input.currentKey).some((piece) => piece.king || ![{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey).some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) || (input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY))"
            ],
            "tests": [
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)",
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color == piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY)",
                "[{ x: 1, y: 1},{ x: 1, y: -1}, { x: -1, y: -1}, { x: -1, y: 1}].some((direction) => this.get_pieces(input, input.currentKey)[0].some((piece) => input[piece.position.x + direction.x][piece.position.y + direction.y].color != Color.EMPTY) && input[piece.position.x + direction.x][piece.position.y + direction.y].color != piece.color && input[piece.position.x + direction.x][piece.position.y + direction.y].color == Color.EMPTY)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Hard",
        "owner_id": 1
    }
    
]