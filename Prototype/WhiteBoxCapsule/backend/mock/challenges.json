[
    {
        "id": 0,
        "name": "Challenge 1.1: Checking for Out of Bounds",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The condition guarding line 9 is made only using OR (||). What does that mean, logically?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x > 7"
            ]
        },
        "achievement": "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x == 10 && input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y == 10",
        "achievement_hint": "For the 1.1 challenge, consider that the numbers for the out of bounds spot start with 1. Start with the lowest number!",
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.2: Thorough Checking of Out of Bounds",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The condition is made only using OR (||)! You need to make sure that the condition yields both True and False.",
        "objective": "Decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "!(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.3: Focus on the Destination",
        "test_cases_count": 5,
        "score": 500,
        "hint": "You only need 5 test cases to pass this challenge. Use the condition table, if needed.",
        "objective": "Modified condition/decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 4,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.4: (Not) Moving Diagonally",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Think about what the condition in line 15 is testing. Knowing you can make all kinds of movements, can't you fulfill the condition?",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.5: Valid and Invalid Movement",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Considering the function is testing for valid moves in Checkers, you only need to make one valid and one invalid move... but validity is dictated by the condition in line 15!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.6: A Valid Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You need to make a valid move, as defined by a certain condition evaluated to false. What condition is it?",
        "objective": "Statement coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "!(Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.7: A Normal Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a Checkers move, you always draw a square (as you follow one of its diagonals). Here, you're given the side of said square.",
        "objective": "Statement coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.8: (Almost) A Capture Move",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a capture in Checkers, you always draw a square (as you follow one of its diagonals). If you have to go OVER a piece, what side does the square have?",
        "objective": "Statement coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.9: All Possible Moves",
        "test_cases_count": 2,
        "score": 350,
        "hint": "If you're making a move in Checkers, you always draw a square (as you follow one of its diagonals). Each case corresponds to a difference side length of the square.",
        "objective": "Decision coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.10: Moving to the Right Place",
        "test_cases_count": 1,
        "score": 175,
        "hint": "When you're making a normal movement (not a capture), you can only move to a spot that is one square away from your current position. What other condition must be true?",
        "objective": "Statement coverage of line 20.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.11: Moving to a Wrong Place",
        "test_cases_count": 1,
        "score": 175,
        "hint": "Remember that you can do make things that aren't legal in Checkers! What condition must be false?",
        "objective": "Statement coverage of line 22.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.12: Moving to Places",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Remember that you can do make things that aren't legal in Checkers! There are two clear cases to test, here.",
        "objective": "Decision coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)",
                "(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.13: Not Capturing a Piece, but Very Close",
        "test_cases_count": 1,
        "score": 175,
        "hint": "You don't have to have a piece in between your from and destination positions: notice the condition only cares about the destination!",
        "objective": "Statement coverage of line 26.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.14: An Illegal Capture",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition true? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 28.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.15: Capture",
        "test_cases_count": 1,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 30.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color != input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color && input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color != 'empty'"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.16: Testing Captures",
        "test_cases_count": 2,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false and true, in different boards? Also, remember that only the last movement you made is considered.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color != input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color",
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color == input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.17: Illegal Capture, Under a Condition",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination is True.",
        "objective": "Statement coverage of line 33.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue >= 2"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.18: Capturing Pieces, Under Conditions",
        "test_cases_count": 2,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination yields True and False in two different cases.",
        "objective": "Decision coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2",
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.1: Counting Pieces",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.2: No Pieces to Count",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.3: Counting Pieces, Not Counting Pieces",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.4: Counting Pieces, Only When It Matters",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) <= 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) > 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) <= 12"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.5: Win Conditions, Only When It Matters",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) != 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.6: Win Conditions, But Thoroughly",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) == 0",
                "!(this.count_blue_pieces(input, case_num) == 0) && !(this.count_red_pieces(input, case_num) == 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.7: Counting Pieces, But Thoroughly",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12) && !(this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.8: Counting Pieces On Some Restrictions",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12",
                "this.count_red_pieces(input, case_num) > 12",
                "!(this.count_blue_pieces(input, case_num) > 12)",
                "!(this.count_red_pieces(input, case_num) > 12)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.9: Winning Conditions On Some Restrictions",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0",
                "this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0",
                "this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.10: Valid Positions for Odd Rows",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![1, 3, 5, 7].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.11: Valid Positions for Even Rows",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 21.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![0, 2, 4, 6].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.12: Just Odd Rows",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Not all is what it seems. Pay attention to the code.",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.13: Just Even Rows",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Pay attention to the code. You MUST use the Add button.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.14: All Rows",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Pay attention to the code condition! You don't need to care what's inside the branches of the If, only that execution gets there!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)",
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.15: A Valid Board",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You have a lot of hurdles to get through, and the Add button is your friend - it adds AND removes pieces (check Guide, if needed).",
        "objective": "Statement coverage of line 26.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) <= 12 && this.count_red_pieces(input, input.currentKey) <= 12",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => (Number(piece.position.x) % 2 != 0 && [1, 3, 5, 7].includes(Number(piece.position.y))) || (Number(piece.position.x) % 2 == 0 && [0, 2, 4, 6].includes(Number(piece.position.y))))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.1: A King Piece",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Statement coverage of line 13.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.2: A King Can Go Anywhere",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first is considered.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.3: Testing Kings",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.4: A King and a Peasant",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.5: A Red Piece",
        "test_cases_count": 1,
        "score": 300,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 28.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.6: (NOT) A Red Piece",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 43.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color != Color.RED)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.7: Double The Colors!",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color != Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.8: Under The Condition of Being King",
        "test_cases_count": 2,
        "score": 225,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.9: A Valid Position for a Red Piece",
        "test_cases_count": 1,
        "score": 250,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.10: Can A Red Piece Move?",
        "test_cases_count": 2,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 33.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))",
                "![{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.11: Both Colors Move",
        "test_cases_count": 2,
        "score": 300,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.12: Movement Under a Colorful Condition",
        "test_cases_count": 2,
        "score": 325,
        "hint": "Only one piece satisfying each test is needed. You can check Checkers' rules to know how movement works.",
        "objective": "Condition coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![ { x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 } ].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX + direction.x][newY + direction.y].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.13: Move When Red, Move When Blue",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Condition/decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.14: Testing King Movement Semi-Thoroughly",
        "test_cases_count": 2,
        "score": 325,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color != Color.EMPTY && (input.state[case_num][newX][newY].color == piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.15: Can A Blue Piece Move?",
        "test_cases_count": 2,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 47.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))",
                "![{ x: 1, y: -1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.1: Only One Piece",
        "test_cases_count": 1,
        "score": 125,
        "hint": "You can choose the piece's color. But you must only put one piece!",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).length == 1"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.2: One Piece... or More",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.3: A Piece... Under a Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.4: Decide A Piece... Under a Condition!",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.5: Only One Color!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "An empty board won't work for either test case. Choose a color, but beware of the first If!",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.6: Only One Color... Or Not!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. For the other, pick a color! Beware of the first If.",
        "objective": "Decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!(this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.7: Another Colorful Condition",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board CAN work for one of the needed test cases. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.8: Another Colorful Condition",
        "test_cases_count": 1,
        "score": 250,
        "hint": "Could an empty board work? You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Statement coverage of line 10.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.get_pieces(input, input.currentKey).length != 1"
            ],
            "tests": [
                "!(this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.9: Thoroughly Testing the Colorful Condition",
        "test_cases_count": 3,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every(piece => piece.color == Color.RED) && !this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)",
                "!this.get_pieces(input, case_num).every(piece => piece.color == Color.RED) && this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)",
                "this.get_pieces(input, case_num).length == 0 || (!(this.get_pieces(input, case_num).every(piece => piece.color == Color.RED)) && !(this.get_pieces(input, case_num).every(piece => piece.color == Color.BLUE)))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.1: Equal Footing",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Zero is a number, just saying.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.2: Evenly Matched... or Not!",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number, by the way. But you can't use it for both test cases!",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.3: Equally Conditioned",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number! But it's not useful for both test cases.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.4: Equally Conditioned Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Zero is a number! But it's not useful for both test cases.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.5: Everyone Wins!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "You cannot use zero here. In the most basic terms (number of pieces per player), what is a tie?",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.6: No One Wins?",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Only one number of pieces per player will work here. Remember: the board is an 8 by 8 grid!",
        "objective": "Statement coverage of line 11.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.7: A Tie... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.8: Conditioned Tie",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Condition coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.9: Conditioning and Deciding A Tie",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Only one number of pieces per player is at play here. Remember: the board is an 8 by 8 grid!",
        "objective": "Condition/decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "this.count_empty_spaces(input, case_num) == 64",
                "this.count_empty_spaces(input, case_num) != 64"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.10: Not A Tie",
        "test_cases_count": 1,
        "score": 100,
        "hint": "You can't use zero, here... That would lead to an early return!",
        "objective": "Statement coverage of line 14.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.11: A Blue (But Not Sad) Victory!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.12: A Red (But Not Angry) Victory!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.13: Colorful Victories",
        "test_cases_count": 2,
        "score": 225,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.14: Colorful Conditioned Victories",
        "test_cases_count": 2,
        "score": 250,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Condition coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.15: Colorful Conditioned Decisions",
        "test_cases_count": 2,
        "score": 275,
        "hint": "One game must be won by each color. For that to happen, you just need a difference of 1 piece between players.",
        "objective": "Condition/decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.1: Build-a-Triangle",
        "test_cases_count": 1,
        "score": 175,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 7.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.2: Don't-Build-a-Triangle",
        "test_cases_count": 1,
        "score": 100,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.3: Triangular Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Decision coverage of line 6.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.4: Triangular Condition",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Condition coverage of line 6.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.5: Triangular Conditional Decision",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Condition/decision coverage of line 6.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.6: Don't-Build-Or-Build-a-Triangle",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Decision coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.7: Triangulating Condition",
        "test_cases_count": 2,
        "score": 450,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Condition coverage of line 9.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.8: Never A Scalene Triangle",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You cannot make a triangle, nor can the condition on line 9 be hit!",
        "objective": "Statement coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey) && this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.9: Conditioning An Isosceles Triangle",
        "test_cases_count": 2,
        "score": 450,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. You're dealing with two separate conditions, so cover True-False state for each, across two test cases! Also, notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Condition coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey) && this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.10: Deciding If It's An Isosceles Triangle",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || (this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)))",
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.11: In Theory, An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Statement coverage of line 13",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.12: Thoroughly Testing A Theoretical Isosceles Triangle",
        "test_cases_count": 3,
        "score": 350,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Modified condition/decision coverage of line 11",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) == this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.13: Thoroughly Testing A Theoretical Scalene Triangle",
        "test_cases_count": 3,
        "score": 350,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Modified condition/decision coverage of line 9",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) >= this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) <= this.count_red_pieces(input, case_num) && this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.14: If This Was A Triangle, We'd Be Concerned",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Treat the first three If conditions as landmines - you can't cover them!",
        "objective": "Statement coverage of line 15.",
        "initial_board": 1,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)) || !(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.1: Draw A Right Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 31.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.2: Don't Draw A Right Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.3: Drawing A Right Triangle... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Decision coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.4: Drawing A Right Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Condition coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.5: Drawing A Right Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Condition/decision coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3"
            ],
            "tests": [
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) == Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.6: Draw A Scalene Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 33.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.7: Don't Draw A Scalene Triangle",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 34.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.8: Draw A Scalene Triangle... Or Not!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.9: Draw A Scalene Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Condition coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.10: Draw A Scalene Triangle... Under A Condition!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Here, the comment in line 2 is not that helpful - actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Condition/decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, case_num).length == 3",
                "Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])].sort()[2], 2))"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, case_num)[0], this.find_blue_pieces(input, case_num)[1]), this.distance(this.find_blue_pieces(input, case_num)[1], this.find_blue_pieces(input, case_num)[2]), this.distance(this.find_blue_pieces(input, case_num)[2], this.find_blue_pieces(input, case_num)[0])]).size == 3)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.11: Draw An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 35.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.12: Don't Draw An Isosceles Triangle",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.13: Theoretically, It's An Equilateral Triangle",
        "test_cases_count": 1,
        "score": 200,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Statement coverage of line 37.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length <= 3",
                "this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]) == 0 || (Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2)) + Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2)) != Math.round(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)))",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && [...(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]))] == 0"
            ]
        },
        "achievement": null,
        "achievement_hint": null,
        "difficulty": "Hard",
        "owner_id": 1
    }
]