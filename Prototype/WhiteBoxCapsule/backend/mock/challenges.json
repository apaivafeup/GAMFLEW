[
    {
        "id": 0,
        "name": "Challenge 1.1: Checking for Out of Bounds",
        "description": "Pieces can never leave the board.",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The condition guarding line 9 is made only using OR (||). What does that mean, logically?",
        "objective": "Statement coverage of line 9.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y > 7 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x < 0 || input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x > 7"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.2: Thorough Checking of Out of Bounds",
        "description": "What if pieces could go out of bounds?",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The condition is made only using OR (||)! You need to make sure that the condition yields both True and False.",
        "objective": "Decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "!(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.3: Focus on the Destination",
        "description": "In this challenge, only the destination is tested, as thoroughly as possible.",
        "test_cases_count": 5,
        "score": 500,
        "hint": "You only need 5 test cases to pass this challenge. Use the condition table, if needed.",
        "objective": "Modified condition/decision coverage of lines 7-8.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 4,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y < 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y > 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x < 0 || input.log[case_num][input.log[case_num].length - 1].destination.x <= 7)",
                "(input.log[case_num][input.log[case_num].length - 1].destination.y >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.y <= 7 || input.log[case_num][input.log[case_num].length - 1].destination.x >= 0 || input.log[case_num][input.log[case_num].length - 1].destination.x > 7)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.4: (Not) Moving Diagonally",
        "description": "Checkers only allows for diagonal movement. You need to avoid that, in this challenge.",
        "test_cases_count": 1,
        "score": 100,
        "hint": "Think about what the condition in line 15 is testing. Knowing you can make all kinds of movements, can't you fulfill the condition?",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.5: Valid and Invalid Movement",
        "description": "In this challenge, you need to test both valid and invalid movement.",
        "test_cases_count": 2,
        "score": 200,
        "hint": "Considering the function is testing for valid moves in Checkers, you only need to make one valid and one invalid move... but validity is dictated by the condition in line 15!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) != Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.6: A Valid Move",
        "description": "In this challenge, you need to make a valid move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You need to make a valid move, as defined by a certain condition evaluated to false. What condition is it?",
        "objective": "Statement coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "!(Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) != Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.7: A Normal Move",
        "description": "In this challenge, you need to make a normal Checkers move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a Checkers move, you always draw a square (as you follow one of its diagonals). Here, you're given the side of said square.",
        "objective": "Statement coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.8: (Almost) A Capture Move",
        "description": "In this challenge, you need to make a capture move.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "If you're making a capture in Checkers, you always draw a square (as you follow one of its diagonals). If you have to go OVER a piece, what side does the square have?",
        "objective": "Statement coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.9: All Possible Moves",
        "description": "In this challenge, you need to test all possible moves!",
        "test_cases_count": 2,
        "score": 350,
        "hint": "If you're making a move in Checkers, you always draw a square (as you follow one of its diagonals). Each case corresponds to a difference side length of the square.",
        "objective": "Decision coverage of line 18.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0"
            ],
            "tests": [
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2",
                "!(Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.10: Moving to the Right Place",
        "description": "In this challenge, you need to make an actual Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "When you're making a normal movement (not a capture), you can only move to a spot that is one square away from your current position. What other condition must be true?",
        "objective": "Statement coverage of line 20.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.11: Moving to a Wrong Place",
        "description": "In this challenge, you need to make an illegal Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "Remember that you can do make things that aren't legal in Checkers! What condition must be false?",
        "objective": "Statement coverage of line 22.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.12: Moving to Places",
        "description": "In this challenge, you need to make an illegal and a totally valid Checkers move!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Remember that you can do make things that aren't legal in Checkers! There are two clear cases to test, here.",
        "objective": "Decision coverage of line 19.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 1"
            ],
            "tests": [
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)",
                "(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.13: Not Capturing a Piece, but Very Close",
        "description": "In this challenge, you need to make a potentially valid Checkers move!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "You don't have to have a piece in between your from and destination positions: notice the condition only cares about the destination!",
        "objective": "Statement coverage of line 26.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "(input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.14: An Illegal Capture",
        "description": "To make sure captures work correctly.",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition true? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 28.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color == input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.15: Capture",
        "description": "Testing a real capture move.",
        "test_cases_count": 1,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false? Also, remember that only the last movement you made is considered.",
        "objective": "Statement coverage of line 30.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].color != input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color && input.state[input.currentKey][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x)/2)][Math.round((input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y + input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)/2)].color != 'empty'"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.16: Testing Captures",
        "description": "Testing a real and an illegal capture move.",
        "test_cases_count": 2,
        "score": 225,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. What does that mean, in terms of the condition in line 27? How can you make the condition false and true, in different boards? Also, remember that only the last movement you made is considered.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color != input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color",
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].color == input.state[case_num][Math.round((input.log[case_num][input.log[case_num].length - 1].start.x + input.log[case_num][input.log[case_num].length - 1].destination.x)/2)][Math.round((input.log[case_num][input.log[case_num].length - 1].start.y + input.log[case_num][input.log[case_num].length - 1].destination.y)/2)].color"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.17: Illegal Capture, Under a Condition",
        "description": "Testing an illegal capture move.",
        "test_cases_count": 1,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination is True.",
        "objective": "Statement coverage of line 33.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[input.currentKey].length > 0",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.y - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y)",
                "Math.abs(input.log[input.currentKey][input.log[input.currentKey].length - 1].start.x - input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.red + input.state[input.currentKey][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.x][input.log[input.currentKey][input.log[input.currentKey].length - 1].destination.y].stack.blue >= 2"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 1.18: Capturing Pieces, Under Conditions",
        "description": "Testing an illegal capture and a valid capture move.",
        "test_cases_count": 2,
        "score": 175,
        "hint": "There's only one way to capture a piece in Checkers: you move over it. In this case, you need to make sure a condition related to the destination yields True and False in two different cases.",
        "objective": "Decision coverage of line 25.",
        "initial_board": 2,
        "code_file": 1,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "input.log[case_num].length > 0",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == Math.abs(input.log[case_num][input.log[case_num].length - 1].start.y - input.log[case_num][input.log[case_num].length - 1].destination.y)",
                "Math.abs(input.log[case_num][input.log[case_num].length - 1].start.x - input.log[case_num][input.log[case_num].length - 1].destination.x) == 2"
            ],
            "tests": [
                "input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2",
                "!(input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.red + input.state[case_num][input.log[case_num][input.log[case_num].length - 1].destination.x][input.log[case_num][input.log[case_num].length - 1].destination.y].stack.blue >= 2)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.1: Counting Pieces",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > 12 || this.count_red_pieces(input, input.currentKey) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.2: No Pieces to Count",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 1,
        "score": 100,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == 0 || this.count_red_pieces(input, input.currentKey) == 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.3: Counting Pieces, Not Counting Pieces",
        "description": "Is the number of pieces possible?",
        "test_cases_count": 2,
        "score": 200,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed.",
        "objective": "Decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 || this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.4: Counting Pieces, Only When It Matters",
        "description": "Not all test cases are equal in this challenge.",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) <= 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) > 12",
                "this.count_blue_pieces(input, case_num) <= 12 && this.count_red_pieces(input, case_num) <= 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.5: Win Conditions, Only When It Matters",
        "description": "Only some test cases are relevant in this challenge.",
        "test_cases_count": 3,
        "score": 300,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table is probably your best friend, here.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) != 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0 && this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.6: Win Conditions, But Thoroughly",
        "description": "All test cases are relevant in this challenge.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0 && this.count_red_pieces(input, case_num) == 0",
                "!(this.count_blue_pieces(input, case_num) == 0) && !(this.count_red_pieces(input, case_num) == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.7: Counting Pieces, But Thoroughly",
        "description": "You need to submit all possible test cases in this challenge.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) > 12) && !(this.count_red_pieces(input, case_num) > 12)",
                "this.count_blue_pieces(input, case_num) > 12 && this.count_red_pieces(input, case_num) > 12"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.8: Counting Pieces On Some Restrictions",
        "description": "You need to cover all values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) > 12",
                "this.count_red_pieces(input, case_num) > 12",
                "!(this.count_blue_pieces(input, case_num) > 12)",
                "!(this.count_red_pieces(input, case_num) > 12)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.9: Winning Conditions On Some Restrictions",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [],
            "tests": [
                "this.count_blue_pieces(input, case_num) == 0",
                "this.count_red_pieces(input, case_num) == 0",
                "this.count_blue_pieces(input, case_num) != 0",
                "this.count_red_pieces(input, case_num) != 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.10: Valid Positions for Odd Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![1, 3, 5, 7].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.11: Valid Positions for Even Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "The Add button allows you to add or remove pieces. Check the Guide if needed. The Condition Table may help, here.",
        "objective": "Statement coverage of line 21.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => ![0, 2, 4, 6].includes(Number(piece.position.y)) && Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.12: Just Odd Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Not all is what it seems. Pay attention to the code.",
        "objective": "Statement coverage of line 16.",
        "initial_board": 2,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.13: Just Even Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Pay attention to the code. You MUST use the Add button.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.14: All Rows",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Pay attention to the code condition! You don't need to care what's inside the branches of the If, only that execution gets there!",
        "objective": "Decision coverage of line 15.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 0,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 != 0)",
                "this.get_pieces(input, input.currentKey).some((piece) => Number(piece.position.x) % 2 == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 2.15: A Valid Board",
        "description": "You need to cover all possible values in this challenge, with limited test cases.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You have a lot of hurdles to get through, and the Add button is your friend - it adds AND removes pieces (check Guide, if needed).",
        "objective": "Statement coverage of line 26.",
        "initial_board": 1,
        "code_file": 2,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) <= 12 && this.count_red_pieces(input, input.currentKey) <= 12",
                "this.count_blue_pieces(input, input.currentKey) != 0 && this.count_red_pieces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every((piece) => (Number(piece.position.x) % 2 != 0 && [1, 3, 5, 7].includes(Number(piece.position.y))) || (Number(piece.position.x) % 2 == 0 && [0, 2, 4, 6].includes(Number(piece.position.y))))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.1: A King Piece",
        "description": "You're going to meet royalty!",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Statement coverage of line 13.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.2: A King Can Go Anywhere",
        "description": "Royals have no restrictions!",
        "test_cases_count": 1,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first is considered.",
        "objective": "Statement coverage of line 20.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.3: Testing Kings",
        "description": "Not all royalty can move freely.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.4: A King and a Peasant",
        "description": "Some pieces aren't born into royalty.",
        "test_cases_count": 2,
        "score": 250,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.5: A Red Piece",
        "description": "Some peasants are red.",
        "test_cases_count": 1,
        "score": 300,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 28.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.6: (NOT) A Red Piece",
        "description": "Some peasants aren't red.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Statement coverage of line 43.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color != Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.7: Double The Colors!",
        "description": "Some peasants are red, others are not.",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Don't forget the function cannot return before reaching the line you have to cover!",
        "objective": "Decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color != Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.8: Under The Condition of Being King",
        "description": "Some pieces aren't born into royalty.",
        "test_cases_count": 2,
        "score": 225,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of line 12.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.king)",
                "!this.get_pieces(input, case_num).some((piece) => piece.king)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.9: A Valid Position for a Red Piece",
        "description": "They need to go 'down'!",
        "test_cases_count": 1,
        "score": 250,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, input.currentKey) != 64",
                "this.get_pieces(input, input.currentKey).some((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, input.currentKey).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[input.currentKey][newX][newY].color == Color.EMPTY || (input.state[input.currentKey][newX][newY].color != piece.color && input.state[input.currentKey][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.10: Can A Red Piece Move?",
        "description": "Only if they go 'down'!",
        "test_cases_count": 2,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 33.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))",
                "![{ x: 1, y: 1}, { x: -1, y: 1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.RED && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.11: Both Colors Move",
        "description": "They go in opposite directions!",
        "test_cases_count": 2,
        "score": 300,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    
    {
        "id": 0,
        "name": "Challenge 3.12: Movement Under a Colorful Condition",
        "description": "They go in opposite directions!",
        "test_cases_count": 2,
        "score": 325,
        "hint": "Only one piece satisfying each test is needed. You can check Checkers' rules to know how movement works.",
        "objective": "Condition coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![ { x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 } ].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX + direction.x][newY + direction.y].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.13: Move When Red, Move When Blue",
        "description": "Making decisions according to conditions!",
        "test_cases_count": 2,
        "score": 350,
        "hint": "Only one piece satisfying the test is needed - if you put more than one, only the first one's considered. You can check Checkers' rules to know how movement works.",
        "objective": "Condition/decision coverage of line 27.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ],
            "tests": [
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.14: Testing King Movement Semi-Thoroughly",
        "description": "Not all royalty can move freely!",
        "test_cases_count": 2,
        "score": 325,
        "hint": "You can check Checkers' rules to know how one makes a King. Only one piece is needed - if you put more than one, only the first one's considered.",
        "objective": "Condition coverage of lines 17-19.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 3,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.king)"
            ],
            "tests": [
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color != Color.EMPTY && (input.state[case_num][newX][newY].color == piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))",
                "[{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 3.15: Can A Blue Piece Move?",
        "description": "Only if they go 'down'!",
        "test_cases_count": 2,
        "score": 450,
        "hint": "Only one piece needs to pass the test in each test case! You can check Checkers' rules to know how movement works.",
        "objective": "Decision coverage of line 47.",
        "initial_board": 1,
        "code_file": 3,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).some((piece) => piece.color == Color.BLUE)",
                "![{ x: 1, y: 1 }, { x: 1, y: -1 }, { x: -1, y: -1 }, { x: -1, y: 1 }].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.king && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color == Color.EMPTY)); }))"
            ],
            "tests": [
                "[{ x: 1, y: -1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))",
                "![{ x: 1, y: -1}, { x: -1, y: -1}].some(direction => this.get_pieces(input, case_num).some(piece => { const newX = Number(piece.position.x) + Number(direction.x), newY = Number(piece.position.y) + Number(direction.y); return piece.color == Color.BLUE && newX >= 0 && newX <= 7 && newY >= 0 && newY <= 7 && (input.state[case_num][newX][newY].color == Color.EMPTY || (input.state[case_num][newX][newY].color != piece.color && input.state[case_num][newX + direction.x][newY + direction.y].color != Color.EMPTY)); }))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.1: Only One Piece",
        "description": "Because only one player can win!",
        "test_cases_count": 1,
        "score": 150,
        "hint": "You can choose the piece's color. But you must only put one piece!",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).length != 0"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.2: One Piece... or More",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!this.get_pieces(input, case_num).length == 1"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.3: A Piece... Under a Condition!",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.4: Decide A Piece... Under a Condition!",
        "description": "",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board won't work for either test case. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64"
            ],
            "tests": [
                "this.get_pieces(input, case_num).length == 1",
                "!(this.get_pieces(input, case_num).length == 1)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.5: Only One Color!",
        "description": "",
        "test_cases_count": 1,
        "score": 175,
        "hint": "An empty board won't work for either test case. Choose a color, but beware of the first If!",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.6: Only One Color... Or Not!",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. For the other, pick a color! Beware of the first If.",
        "objective": "Decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)",
                "!(this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.7: Another Colorful Condition",
        "description": "",
        "test_cases_count": 2,
        "score": 275,
        "hint": "An empty board CAN work for one of the needed test cases. One test with ONE piece only, and another test that is anything EXCEPT that!",
        "objective": "Condition coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "this.get_pieces(input, case_num).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, case_num).every((piece) => piece.color == Color.RED)",
                "this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.BLUE)",
                "!this.get_pieces(input, input.currentKey).every((piece) => piece.color == Color.RED)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.8: Another Colorful Condition",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Statement coverage of line 10.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).length != 1",
                "!(this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 4.9: Thoroughly Testing the Colorful Condition",
        "description": "",
        "test_cases_count": 3,
        "score": 250,
        "hint": "An empty board CAN work for one of the needed test cases. You need to avoid the Ifs from lines 5 and 7.",
        "objective": "Modified condition/decision coverage of line 7.",
        "initial_board": 1,
        "code_file": 4,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_empty_spaces(input, case_num) != 64",
                "this.get_pieces(input, input.currentKey).length != 1"
            ],
            "tests": [
                "this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || !this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE)",
                "!this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE)",
                "!this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.RED) || !this.get_pieces(input, input.currentKey).every(piece => piece.color == Color.BLUE)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.1: Equal Footing",
        "description": "",
        "test_cases_count": 1,
        "score": 100,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.2: Evenly Matched... or Not!",
        "description": "",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.3: Equally Conditioned",
        "description": "",
        "test_cases_count": 2,
        "score": 200,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
            ],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.4: One Is Victorious",
        "description": "",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.5: One Is (Not) Victorious (?)",
        "description": "",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 11.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.6: A Tie... Or Not!",
        "description": "",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.7: Conditioned Tie",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.8: Conditioning and Deciding A Tie",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition/decision coverage of line 6.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) == this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_empty_spaces(input, input.currentKey) == 64",
                "this.count_empty_spaces(input, input.currentKey) != 64"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.9: Equally Decided and Conditioned",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition/decision coverage of line 5.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
            ],
            "tests": [
                "this.count_red_pieces(input, case_num) == this.count_blue_pieces(input, case_num)",
                "this.count_red_pieces(input, case_num) != this.count_blue_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.10: Not A Tie",
        "description": "",
        "test_cases_count": 2,
        "score": 100,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 14.",
        "initial_board": 1,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                
            ],
            "tests": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.11: A Blue (But Not Sad) Victory!",
        "description": "",
        "test_cases_count": 2,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.12: A Red (But Not Angry) Victory!",
        "description": "",
        "test_cases_count": 2,
        "score": 125,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 17.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.13: Colorful Victories",
        "description": "",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))",
                "(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.14: Colorful Conditioned Victories",
        "description": "",
        "test_cases_count": 2,
        "score": 250,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))",
                "(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 5.15: Colorful Conditioned Decisions",
        "description": "",
        "test_cases_count": 2,
        "score": 275,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Condition/decision coverage of line 14.",
        "initial_board": 2,
        "code_file": 5,
        "challenge_type": "condition/decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != this.count_blue_pieces(input, input.currentKey)"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))",
                "(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.1: Build-a-Triangle",
        "description": "Yes, we're taking you back to Middle School. You're going to build a triangle, and you're going to like it!",
        "test_cases_count": 1,
        "score": 175,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. Also, each triangle's side must be greater than 0 when measured.",
        "objective": "Statement coverage of line 8.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.count_red_pieces(input, input.currentKey) != 0",
                "this.count_blue_pieces(input, input.currentKey) != 0",
                "this.count_empty_spaces(input, input.currentKey) != 0"
            ],
            "tests": [
                "this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.2: Don't-Build-a-Triangle",
        "description": "Yes, we're taking you back to Middle School. You're going to build a triangle, and you're going to like it!",
        "test_cases_count": 1,
        "score": 100,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces. How can you make it so their numbers don't make a triangle?",
        "objective": "Statement coverage of line 10.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.3: Don't-Build-Or-Build-a-Triangle",
        "description": "Yes, we're taking you back to Middle School.",
        "test_cases_count": 2,
        "score": 300,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Decision coverage of line 10.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.4: Triangulating Condition",
        "description": "Yes, we're taking you back to Middle School.",
        "test_cases_count": 2,
        "score": 300,
        "hint": "If you have no idea how to test values for a triangle, look up the concept of triangle inequality. You only have three variables - red pieces, blue pieces, and empty spaces.",
        "objective": "Condition coverage of line 10.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
            ],
            "tests": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))",
                "this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.5: Not Quite a Scalene Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle. That means one side can be equal to zero!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Though it's all tested at once, you're dealing with two separate conditions. Each case needs to cover True-False state for each, across two tests! Notice how the variables' meaning (i.e., variable a will always count red pieces) never changes!",
        "objective": "Condition coverage of line 10.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num))",
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num)",
                "this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)",
                "!(this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.6: Possibly, A Scalene Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle. That means one side can be equal to zero!",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Though it's all tested at once, you're dealing with two separate conditions. Each case needs to cover True-False state for each, across two tests! Notice how the variables' meaning (i.e., variable a will always count red pieces) never changes!",
        "objective": "Statement coverage of line 11.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey) && this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.7: An Out of Scale(ne) Decision",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle. That means one side can be equal to zero!",
        "test_cases_count": 2,
        "score": 300,
        "hint": "Though it's all tested at once, you're dealing with two separate parts in the decision. Each test case must cover each possible decision!",
        "objective": "Decision coverage of line 10.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 2,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num))",
                "this.count_blue_pieces(input, case_num) < this.count_empty_spaces(input, case_num) && this.count_blue_pieces(input, case_num) > this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.8: Conditioning An Isosceles Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle, but with two equal values.",
        "test_cases_count": 2,
        "score": 300,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. You're dealing with two separate conditions, so cover True-False state for each, across two test cases! Also, notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Condition coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num)",
                "this.count_blue_spaces(input, case_num) == this.count_red_pieces(input, case_num)",
                "this.count_blue_pieces(input, case_num) != this.count_empty_spaces(input, case_num)",
                "this.count_blue_spaces(input, case_num) != this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.9: Conditioning An Isosceles Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle, but with two equal values.",
        "test_cases_count": 2,
        "score": 225,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Decision coverage of line 12.",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, case_num), this.count_blue_pieces(input, case_num), this.count_empty_spaces(input, case_num))"
            ],
            "tests": [
                "!(this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || (this.count_blue_spaces(input, case_num) == this.count_red_pieces(input, case_num)))",
                "this.count_blue_pieces(input, case_num) == this.count_empty_spaces(input, case_num) || this.count_blue_spaces(input, case_num) == this.count_red_pieces(input, case_num)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.10: In Theory, An Isosceles Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle, but with two equal values.",
        "test_cases_count": 1,
        "score": 125,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "Statement coverage of line 13",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_spaces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.11: Thoroughly Testing A Theoretical Isosceles Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle, but with two equal values.",
        "test_cases_count": 3,
        "score": 325,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "MCDC coverage of line 12",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "!this.count_blue_pieces(input, input.currentKey) == this.count_red_spaces(input, input.currentKey) && this.count_blue_spaces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey)",
                "this.count_blue_pieces(input, input.currentKey) == this.count_red_spaces(input, input.currentKey) && !this.count_blue_spaces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey)",
                "!this.count_blue_pieces(input, input.currentKey) == this.count_red_spaces(input, input.currentKey) && !this.count_blue_spaces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.12: Thoroughly Testing A Theoretical Scalene Triangle",
        "description": "We really think people ought to remember middle school math. This time, you're going to purposefully NOT build a valid triangle, but with two equal values.",
        "test_cases_count": 3,
        "score": 325,
        "hint": "If it's not a triangle, sides don't have to be greater than 0. Notice how the code forces you to fix two of the variables with the same value, but the pair must include variable b!",
        "objective": "MCDC coverage of line 10",
        "initial_board": 3,
        "code_file": 6,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": 1,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))"
            ],
            "tests": [
                "!this.count_blue_pieces(input, input.currentKey) > this.count_red_spaces(input, input.currentKey) && this.count_blue_spaces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)",
                "this.count_blue_pieces(input, input.currentKey) > this.count_red_spaces(input, input.currentKey) && !this.count_blue_spaces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)",
                "!this.count_blue_pieces(input, input.currentKey) > this.count_red_spaces(input, input.currentKey) && !this.count_blue_spaces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 6.13: If This Was A Triangle, We'd Be Concerned",
        "description": "We encourage creativity on this one. But we make no reservations about the results.",
        "test_cases_count": 1,
        "score": 150,
        "hint": "Treat the first three If conditions as landmines - you can't cover them!",
        "objective": "Statement coverage of line 15.",
        "initial_board": 1,
        "code_file": 6,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "!this.isTriangle(this.count_red_pieces(input, input.currentKey), this.count_blue_pieces(input, input.currentKey), this.count_empty_spaces(input, input.currentKey))",
                "!(this.count_blue_pieces(input, input.currentKey) < this.count_empty_spaces(input, input.currentKey)) || !(this.count_blue_pieces(input, input.currentKey) > this.count_red_pieces(input, input.currentKey))"  
            ],
            "tests": [
                "!(this.count_blue_pieces(input, input.currentKey) == this.count_empty_spaces(input, input.currentKey) || this.count_blue_pieces(input, input.currentKey) == this.count_red_pieces(input, input.currentKey))"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.1: Draw A Right Triangle",
        "description": "Do you remember the Pythagorean Theorem? Be honest. Either way, you shall be reminded!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 31.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "function six_one() { return Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2); } six_one();"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.2: Don't Draw A Right Triangle",
        "description": "Do you remember the Pythagorean Theorem? Be honest. Either way, you shall be reminded!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Statement coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.3: Drawing A Right Triangle... Or Not!",
        "description": "Do you remember the Pythagorean Theorem? Be honest. Either way, you shall be reminded!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Decision coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "function six_one() { return (Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.4: Drawing A Right Triangle... Under A Condition!",
        "description": "Do you remember the Pythagorean Theorem? Be honest. Either way, you shall be reminded!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Notice the comment in line 2 - it can help you understand which side is which!",
        "objective": "Condition coverage of line 30.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "function six_one() { return (Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.5: Draw A Scalene Triangle",
        "description": "You might have to Google this one. But it's not that hard, we promise!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that help- Actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 33.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.6: Don't Draw A Scalene Triangle",
        "description": "You might have to Google this one. But it's not that hard, we promise!",
        "test_cases_count": 1,
        "score": 125,
        "hint": "Here, the comment in line 2 is not that help- Actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Statement coverage of line 34.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.7: Draw A Scalene Triangle... Or Not!",
        "description": "You might have to Google this one. But it's not that hard, we promise!",
        "test_cases_count": 2,
        "score": 225,
        "hint": "Here, the comment in line 2 is not that help- Actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.8: Draw A Scalene Triangle... Under A Condition!",
        "description": "You might have to Google this one. But it's not that hard, we promise!",
        "test_cases_count": 2,
        "score": 250,
        "hint": "Here, the comment in line 2 is not that help- Actually, it's a bait! Don't fall for it - the order is irrelevant, here!",
        "objective": "Decision coverage of line 32.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Normal",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.9: Draw An Isosceles Triangle",
        "description": "Be honest, did you remember these ones? We hope so! Once again, it's an easy challenge.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 35.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.10: Don't Draw An Isosceles Triangle",
        "description": "Be honest, did you remember these ones? We hope so! Once again, it's an easy challenge.",
        "test_cases_count": 1,
        "score": 250,
        "hint": "An isosceles triangle has only two equal sides. It doesn't matter which ones you choose to be equal.",
        "objective": "Statement coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 3"
            ],
            "tests": [
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Easy",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.11: (Don't) Draw An Equilateral Triangle",
        "description": "Believe it or not, it's impossible... Unless we get creative!",
        "test_cases_count": 1,
        "score": 200,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Statement coverage of line 37.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "statement",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 0",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.12: Equilateral Triangles... Or Not!",
        "description": "Believe it or not, it's impossible... Unless we get creative!",
        "test_cases_count": 2,
        "score": 300,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Decision coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "decision",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 0",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.13: Equilateral Triangles... Under A Condition!",
        "description": "Believe it or not, it's impossible... Unless we get creative!",
        "test_cases_count": 2,
        "score": 400,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Decision coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "condition",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 0",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0)"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Hard",
        "owner_id": 1
    },
    {
        "id": 0,
        "name": "Challenge 7.14: Thoroughly Testing Equilateral Triangles",
        "description": "Believe it or not, it's impossible... Unless we get creative!",
        "test_cases_count": 3,
        "score": 500,
        "hint": "No checks are performed on the triangle's sides, so you can make them equal. But how? ",
        "objective": "Decision coverage of line 36.",
        "initial_board": 1,
        "code_file": 7,
        "challenge_type": "mcdc",
        "passing_criteria": {
            "expression_count": null,
            "preconditions": [
                "this.find_blue_pieces(input, input.currentKey).length == 0",
                "function six_one() { return !(Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[0], 2) + Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[1], 2) == Math.pow([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])].sort()[2], 2)); } six_one();",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 3)",
                "!(new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 2)"
            ],
            "tests": [
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0",
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size != 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] == 0",
                "new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1 && (new Set([this.distance(this.find_blue_pieces(input, input.currentKey)[0], this.find_blue_pieces(input, input.currentKey)[1]), this.distance(this.find_blue_pieces(input, input.currentKey)[1], this.find_blue_pieces(input, input.currentKey)[2]), this.distance(this.find_blue_pieces(input, input.currentKey)[2], this.find_blue_pieces(input, input.currentKey)[0])]).size == 1)[0] != 0"
            ]
        },
        "achievement_criteria": null,
        "difficulty": "Very Hard",
        "owner_id": 1
    }
]