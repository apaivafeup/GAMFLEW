[
    {
        "id": 1,
        "name": "Test File 1: Is Move Valid?",
        "content": "// board includes the board's state.\n// start: the (x, y) position from where a piece last moved.\n// destination: the (x, y) position to where a piece last moved.\nfunction is_valid_move(board, start, destination) {\n\t// Math.abs() gives you the absolute value of whatever you call it with.\n\t// Math.abs(-1) == 1\n\tif (destination.x < 0 || destination.x > 7 ||\n\t\tdestination.y < 0 || destination.y > 7) {\n\t\treturn false;\n\t}\n\n\tvar lineDifference = Math.abs(start.x - destination.x);\n\tvar columnDifference = Math.abs(start.y - destination.y);\n\n\tif (lineDifference != columnDifference) {\n\t\treturn false;\n\t} else {\n\t\tif (lineDifference == 1) {\n\t\t\tif (board[destination.x][destination.y].color == Color.EMPTY) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (lineDifference == 2) {\n\t\t\tif (board[destination.x][destination.y].color == Color.EMPTY) {\n\t\t\t\tvar middlePiece = board[Math.round((start.x + destination.x) / 2)][Math.round((start.y + destination.y) / 2)];\n\t\t\t\tif (middlePiece.color == board[start.x][start.y].color) {\n\t\t\t\t\treturn false;\n\t\t\t\t} else if (middlePiece.color != Color.EMPTY) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
    },
    {
        "id": 2,
        "name": "Test File 2: Is Board Valid?",
        "content": "function is_board_valid(board) { // board is the board's state.\n\tvar bluePieces = this.count_blue_pieces(board);\n\tvar redPieces = this.count_red_pieces(board);\n\n\tif (bluePieces > 12 || redPieces > 12) {\n\t\treturn false;\n\t} else if (bluePieces == 0 || redPieces == 0) {\n\t\treturn false;\n\t}\n\n\tvar pieces = this.get_pieces(board);\n\tvar odd = [1, 3, 5, 7], even = [0, 2, 4, 6];\n\n\tfor (p in pieces) {\n\t\tif (p.position.row % 2 != 0) {\n\t\t\tif (!odd.includes(p.position.column)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tif (!even.includes(p.position.column)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}"
    },
    {
        "id": 3,
        "name": "Test File 3: Can Piece Move?",
        "content": "function can_piece_move(piece) {\n\t// Checking diagonals, clockwise, starting on top-right quadrant.\n\t// Quadrants are: top-right, bottom-right, bottom-left, top-left.\n\tvar directions = [\n\t\t{ x: 1, y: 1 },\n\t\t{ x: 1, y: -1 },\n\t\t{ x: -1, y: -1 },\n\t\t{ x: -1, y: 1 },\n\t];\n\n\t// Kings can move in all directions.\n\tif (piece.isKing) {\n\t\tfor (var d of directions) {\n\t\t\tvar destination_x = piece.position.row + d.x,\n\t\t\t\tdestination_y = piece.position.column + d.y ;\n\n\t\t\tif ((board[destination_x][destination_y].color == Color.EMPTY) ||\n\t\t\t\t(board[destination_x][destination_y].color != piece.color &&\n\t\t\t\tboard[destination_x + d.x][destination_y + d.y].color == Color.EMPTY)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Normal pieces can only move in half the directions.\n\t// Blue and red pieces move in opposite directions!\n\tif (piece.color == Color.RED) {\n\t\tfor (var d of [directions[0], directions[3]])) {\n\t\t\tvar destination_x = piece.position.row + d.x,\n\t\t\t\tdestination_y = piece.position.column + d.y ;\n\n\t\t\t// Color.EMPTY represents an empty space.\n\t\t\tif (board[destination_x][destination_y].color == Color.EMPTY ||\n\t\t\t\t(board[destination_x][destination_y].color != piece.color &&\n\t\t\t\tboard[destination_x + d.x][destination_y + d.y].color == Color.EMPTY)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Blue pieces only move 'up', which means\n\t\t// all moves have a negative y component.\n\t\t// They can, however, have a positive or negative x component.\n\t\tfor (var d of [directions[1], directions[2]]) {\n\t\t\tvar destination_x = piece.position.row + d.x,\n\t\t\t\tdestination_y = piece.position.column + d.y ;\n\n\t\t\tif (board[destination_x][destination_y].color == Color.EMPTY ||\n\t\t\t\t(board[destination_x][destination_y].color != piece.color &&\n\t\t\t\tboard[destination_x + d.x][destination_y + d.y].color == Color.EMPTY)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n}"
    },
    {
        "id": 4,
        "name": "Test File 4: Has Game Ended?",
        "content": "function has_game_ended(board) {\n\tvar pieces = this.get_pieces(board);\n\n\t// If there is only one piece left, the game has ended.\n\tif (pieces.length == 1) {\n\t\treturn true;\n\t} else if (pieces.every(p => p.color == Color.RED) || pieces.every(p => p.color == Color.BLUE)) {\n\t\treturn true;\n\t} else {\n\t\treturn false;\n\t}\n}"
    },
    {
        "id": 5,
        "name": "Test File 5: Who Won?",
        "content": "function who_won(board) {\n\tvar blue = this.count_blue_pieces(board),\n\t\tred = this.count_red_pieces(board);\n\n\tif (blue == red) {\n\t\tif (this.count_empty_spaces(board) != 64) {\n\t\t\t// Tie\n\t\t\treturn [Color.RED, Color.BLUE];\n\t\t} else {\n\t\t\t// Invalid board.\n\t\t\treturn null;\n\t\t}\n\t} else {\n\t\tif (blue > red) {\n\t\t\treturn Color.BLUE;\n\t\t} else {\n\t\t\treturn Color.RED;\n\t\t}\n\t}\n}"
    },
    {
        "id": 6,
        "name": "Test File 6: Build A Triangle",
        "content": "function build_a_triangle(board) {\n\tvar a = this.count_red_pieces(board); // Counts the number of blue pieces.\n\tvar b = this.count_blue_pieces(board); // Counts the number of red pieces.\n\tvar c = this.count_empty_spaces(board); // Counts the number of empty spaces (no pieces).\n\t\n\t// Tests if the lengths of the sides of the triangle are valid.\n\tif (this.is_triangle(a, b, c)) {\n\t\treturn true;\n\t} else {\n\t\tif (b < c && b > a) {\n\t\t\treturn true;\n\t\t} else if (b == a || b == c) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}"
    },
    {
        "id": 7,
        "name": "Test File 7: Draw A Triangle",
        "content": "function draw_a_triangle(board) {\n\t// This function finds all blue pieces in the board and\n\t// returns them in a list. The final list is ordered by\n\t// row and column - respectively, (x, y).\n\tvar vertices = this.find_blue_pieces(board)\n\n\tif (vertices.length > 3) {\n\t\treturn;\n\t}\n\n\tvar side_1 = [vertices[0], vertices[1]],\n\t\tside_2 = [vertices[1], vertices[2]],\n\t\tside_3 = [vertices[2], vertices[0]];\n\n\t// This function calculates the Cartesian distance between\n\t// two (x, y) vertices. It rounds up to 2 decimal places.\n\tvar length_1 = this.distance(side_1[0], side_1[1]),\n\t\tlength_2 = this.distance(side_2[0], side_2[1]),\n\t\tlength_3 = this.distance(side_3[0], side_3[1]);\n\n\tvar ordered_sides = [length_1, length_2, length_3].sort();\n\n\tvar side_a = ordered_sides[0],\n\t\tside_b = ordered_sides[1],\n\t\tside_c = ordered_sides[2];\n\n\t// Math.sqrt() calculates the square root of a number.\n\t// Math.pow(number, power) calculates number^power.\n\t// Sets are like lists, but they contain no duplicates.\n\tif (Math.sqrt(Math.pow(side_a, 2) + Math.pow(side_b, 2)) == side_c) {\n\t\treturn true;\n\t} else if (new Set([side_a, side_b, side_c]).size == 3) {\n\t\treturn true;\n\t} else if (new Set([side_a, side_b, side_c]).size == 2) {\n\t\treturn true;\n\t} else if (new Set([side_a, side_b, side_c]).size == 1 && side_a == 0) {\n\t\treturn false;\n\t}\n}"
    }
]